3. DESENVOLVIMENTO DE UM PARSER SINTÁTICO I 
3.0. Noções teóricas importantes Como vimos, desenvolver um parser envolve tanto conhecimentos linguísticos como computacionais. Por isso, julgamos que este capítulo devesse ser dividido em duas grandes seções: uma que trata das teorias linguísticas que adotaremos para desenvolver nosso pequeno parser (veremos um pouco mais sobre o estudo sintático das línguas naturais); e outra que aborde a teoria computacional que está por trás de sua construção e implementação (veremos um pouco mais sobre a linguagem Prolog). É importante lembrar que partimos do pressuposto de que nosso leitor seja um linguista (nada contra qualquer outro pesquisador de qualquer outra área!). Apenas queremos dizer que nosso leitor-ideal provavelmente já esteja parcialmente habituado à teoria linguística, mas pouco — ou nada — ainda acostumado com os formalismos computacionais. Por isso, explicaremos apenas alguns termos que julgamos ser fundamentais à teoria linguística e que devem ser definidos e explicitados para que o leitor saiba quais princípios e teorias estão por trás do desenvolvimento de nosso pequeno parser (como, por exemplo, o que entendemos por gramática, o que é uma estrutura de constituintes, o que são representações arbóreas da sentença etc.). Em alguns momentos, entretanto, faremos referência a certos pontos da teoria que acreditamos já serem conhecidos do leitor e abster-nos-emos de parar para maiores explanações. Ao mesmo tempo, por algumas vezes, faremos referência a obras de autores conhecidos na literatura pertinente, pressupondo que o 

 35 leitor já os conheça. Se surgirem dúvidas, remetemos o leitor, a qualquer momento, ao nosso Glossário, que está no final deste livro. Sobre a teoria computacional, no entanto, partiremos da marca zero, ou quase isso. Tentaremos ser claros ao máximo em nossas explicações envolvendo a parte computacional, embora não nos interesse discutir todo o formalismo da linguagem Prolog; veremos apenas os pontos que nos são pertinentes para o desenvolvimento de um parser.  Isso tudo quer dizer que este é um trabalho na área de Linguística Computacional, voltado para linguistas que queiram discutir e aplicar teorias e formalismos sintáticos para o desenvolvimento de parsers na linguagem Prolog. Não é, portanto, um trabalho voltado para a discussão de ferramentas ou linguagens computacionais que trabalhem com a linguagem natural. 3.1. Teoria Linguística 3.1.1. A noção de gramática Um parser, no contexto da Linguística Computacional, é um analisador automático (ou semiautomático) de sentenças. Esse tipo de programa é capaz de analisar uma sentença com base em uma gramática pré-estabelecida de uma determinada língua, verificando se as sentenças fazem parte ou não da língua, de acordo com o que autoriza a sua gramática. Um parser também analisa sintaticamente as sentenças, decompondo-as em uma série de unidades menores, primeiramente em nódulos não-terminais (os sintagmas) até chegar a nódulos terminais (os itens lexicais), atribuindo-lhes uma estrutura de constituintes. Essa estrutura de constituintes, que representa a organização hierárquica e sintática da frase, é apresentada comumente através de árvores sintáticas (como ilustra a representação (3.1a)), ou através de colchetes rotulados (como vemos na representação em (3.1b)). 

 36 Vejamos as representações da sentença (3.1) abaixo: (3.1) O João ama a Maria  (3.1a)  S  SN  SV            Det         N    V        SN      Det  N         O      João ama a      Maria (3.1b) [BSB [BSNB [BDetB O] [BNB João]] [BSVB [BVB ama] [BSNB [BDetB a] [BNB Maria]]]] Onde temos os símbolos: S = sentença SN = sintagma nominal Det = determinante N = nome (ou substantivo) SV = sintagma verbal V = verbo  Essas representações sintáticas das sentenças nos remetem às teorias de Chomsky (especialmente 1971a e 1980 TP1PT) e pressupõem que tenhamos adotado uma determinada teoria ou modelo de parsing, além de uma determinada noção de gramática, relativa a essa teoria.  
TP1PT Convém lembrar ao leitor que Chomsky (1971a) corresponde à versão espanhola do já consagrado Chomsky (1965), e Chomsky (1980) é a versão portuguesa do também consagrado Chomsky (1956), veja nossas Referências Bibliográficas.  Utilizaremos sempre as referências Chomsky (1971a) e (1980), uma vez que faremos menção sempre a essas versões das obras originais de Noam Chomsky. 

 37 O termo gramática em linguística pode ter diversas acepções, que podem ir desde o “sentido restrito de gramática escolar, quer dizer, aquela que pretende dar as normas do bom uso de uma língua” até o “sentido muito amplo e bastante mal definido, como aparece na gramática histórica e comparada” (Nivette, 1975: 1). E, de fato, existem inúmeras noções de gramática (só no dicionário de Dubois et al., 1988, por exemplo, encontramos mais de dez entradas para o termo!2). Entenderemos gramática como sendo um conjunto de regras que nos permitirá, juntamente com um determinado léxico, formar todas as sentenças gramaticais de uma dada língua. Além disso, essa gramática deverá ser capaz de gerar infinitas sentenças (que por sua vez poderiam ser de infinita extensão, não fossem problemas óbvios, como incapacidade de memória, inadequação pragmática etc.) a partir de um número relativamente pequeno de regras de reescrita e de inserção lexical. É o que se tem denominado gramática sintagmática. Em Chomsky (1980: 13) encontramos a seguinte definição de sintaxe e de gramática, que nos parece pertinente: a sintaxe é o estudo dos princípios e processos que presidem à construção de frases em línguas particulares. O estudo sintáctico de uma determinada língua tem como objectivo a construção de uma gramática, que pode ser encarada como um mecanismo de produção de frases da língua em questão. É nesse sentido que podemos empreender nossa jornada na construção da gramática que estará por trás de nosso parser. No entanto, nosso principal objetivo não será desenvolver exatamente um “mecanismo de produção”, mas um “mecanismo de reconhecimento” automático de sentenças em língua portuguesa. Nosso pequeno parser deverá reconhecer as sentenças gramaticais — e somente elas — e atribuir-lhes uma estrutura de constituintes. Mas o que são sentenças gramaticais? E qual a sua relação com sentenças agramaticais? Como sabemos se nossa gramática está gerando  2 Cf. Dubois et al. (1988: 313). 

 38 ou reconhecendo sentenças gramaticais (e apenas elas)?  Vejamos alguns exemplos, que pegamos emprestados de Radford (1981: 7) — que, por sua vez, os tomou de Lakoff (1971: 332)3: (3.2) Meu tio acha que eu sou um mau cozinheiro. (3.3) Meu gato acha que eu sou um mau cozinheiro. (3.4) Meu peixinho dourado acha que eu sou um mau cozinheiro. (3.5) Minha ameba de estimação acha que eu sou um mau cozinheiro. (3.6) Minha panela acha que eu sou um mau cozinheiro. (3.7) Minha sinceridade acha que eu sou um mau cozinheiro. (3.8) Meu nascimento acha que eu sou um mau cozinheiro. TP Quais dessas frases são gramaticais e quais são agramaticais? De acordo com Radford — e de acordo com o nosso entendimento —, todas as sentenças acima são gramaticais, ainda que algumas delas, como (3.3) a (3.8), possam parecer estranhas por alguma razão de ordem pragmática ou semântica. Se adotarmos a premissa de que nosso parser deva reconhecer sentenças gramaticais no sentido sintático estrito, isso significa que ele poderia reconhecer e gerar a estrutura sintagmática de todas essas sentenças. De acordo com Chomsky (1980: 17), “a noção de ‘gramatical’ não poderá identificar-se com as de ‘dotado de sentido’ ou de ‘significativo’, em qualquer sentido semântico”4. Ele ilustra esse ponto com a já consagrada frase (3.9), que é uma sentença gramatical, em contraste com (3.10), nitidamente agramatical (marcada, por convenção, com um asterisco): (3.9) Incolores ideias verdes dormem furiosamente. (3.10) *Verdes dormem incolores furiosamente ideias.   3 LAKOFF, George. Presupposition and relative well-formedness. In: JAKOBOVITS, L. A.; STEINBERG, D. D. Semantics. Cambridge: Cambridge University Press, 1971. 4 Contudo, em Chomsky (1971a), o autor leva em consideração alguns aspectos semânticos no desenvolvimento da teoria gramatical e define alguns graus de gramaticalidade, que não serão discutidos aqui. 

 39   Uma sentença agramatical como (3.10) foge a algumas regras de nossa gramática (entendida aqui como o conjunto de regras sintáticas que geram e reconhecem sentenças bem formadas do português). Veremos nas subseções seguintes mais motivos por que devemos considerar sentenças como (3.9) gramaticais e sequências de palavras como (3.10) agramaticais. Na próxima subseção, apresentaremos a noção que nos possibilita analisar a frase (3.1) através de uma árvore sintática (3.1a) e de uma representação de colchetes rotulados (3.1b). 3.1.2. Gramática sintagmática e teoria de constituintes Quando propusemos a descrição da frase (3.1) acima — repetida aqui como (3.11) —, representando sua estrutura sintática através de um diagrama arbóreo (3.1a) e de colchetes rotulados (3.1b), decidimos adotar uma determinada teoria que nos possibilitasse analisar aquela sentença da maneira que fizemos. Essa análise começa com a divisão da frase em “blocos”, ou sintagmas, e vai até os itens lexicais, desta forma:  (3.11) O João ama a Maria.  O João         ama a Maria      ama  a Maria     O   João  ama       a  Maria   Não dividimos a frase (3.11) sem nenhum critério, agrupando quaisquer grupos de palavras aleatoriamente. Se assim fosse, poderíamos tê-la analisado de várias outras maneiras, formando 

 40 qualquer tipo de agrupamento interno na frase, até chegarmos aos itens lexicais, como em (3.11a) e (3.11b). Poderíamos até mesmo supor que a sentença não tenha qualquer organização interna, sendo formada simplesmente por um aglomerado linear de palavras, como em (3.11c):  (3.11a) O João ama a Maria.     O João ama   a Maria  O João  ama   a Maria    (3.11b)  O João ama a Maria.     O João ama a Maria  O João  ama    a     Maria   (3.11c)  O João ama a Maria.  O João       ama         a  Maria  De acordo com a teoria proposta pela gramática sintagmática, não podemos encarar a sentença como um mero aglomerado de palavras, unidas uma a outra de qualquer forma. Há entre o nível da palavra e o da frase uma outra forma de organização, que é o sintagma (ou constituinte). Quando discutimos anteriormente a noção de gramática e sistema de parsing, dizendo que eles podem analisar a frase em unidades 

 41 — ou agrupamentos — menores, pressupusemos essa noção. Isto é, foi com base nela que falamos antes em SN (Sintagma Nominal) e SV (Sintagma Verbal). Mas vejamos o que nos permite admitir essa noção de constituintes nas sentenças e como sabemos que um determinado grupo de palavras forma um constituinte (ou sintagma). De acordo com Radford (1981: 69): Um certo agrupamento de palavras é um constituinte somente se tiver uma ou mais das seguintes propriedades: (i) Comporta-se distribucionalmente como uma única unidade estrutural, isto é, é recorrente como uma unidade única em uma variedade de outras posições nas frases (ii) Pode ser coordenado com outro agrupamento similar (iii) Não permite intrusão interna de elementos parentéticos (a intrusão geralmente sendo permitida apenas nas fronteiras de constituintes maiores, especialmente sintagmas) (iv) Pode ser substituído por (ou servir de antecedente para) uma proforma (v) Pode ser omitido, sob condições de discurso apropriadas.  Isso quer dizer que podemos realizar diferentes “testes” para identificarmos um constituinte, como os testes de coordenação, interpolação, anáfora, entre outros. Esses testes permitirão identificar os limites dos constituintes, confirmando ou não a nossa própria intuição linguística.  Vejamos mais de perto como os testes de constituintes funcionam. Dada a sentença (3.11), podemos efetuar alguns testes para ter certeza de que nossa representação arbórea proposta algumas páginas atrás esteja correta. O primeiro teste que podemos realizar é o teste de coordenação. Suspeitamos que a organização sintática de (3.11) seja a seguinte (aqui apresentada em colchetes rotulados):  (3.11’) BSB[BSNB[O João] BSVB[ama [BSNB[a Maria]]] Para testarmos a validade de nossa representação, podemos coordenar um outro SN com o SN [O João] e outro SN ao nosso SN [a Maria], unindo-os com a conjunção aditiva e:  

 42 (3.11’a) [O João] e [o Pedro] amam a Maria. (3.11’b) O João ama [a Maria] e [o Pedro]. Podemos coordenar também o SV: (3.11’c) O João [ama [a Maria]] e [odeia [a Joana]]. Note que não poderíamos coordenar elementos que não sejam realmente sintagmas. Não poderíamos, por exemplo, efetuar com sucesso o teste de coordenação se tivéssemos analisado a estrutura sintática de (3.11) como propusemos em (3.11a), (3.11b) e (3.11c) anteriormente: (3.11a) [O João ama] [a Maria] (3.11.a’) ?[O João ama] e [O Pedro adora] a Maria. (3.11b) [O João ama a] [Maria]. (3.11.b’) *[O João ama a] e [o Pedro adora a] Maria. (3.11c) [O] [João] [ama] [a] [Maria]. (3.11c’) *O João ama a [Maria] e [Pedro]. Isso nos leva ao raciocínio que, em regra, a coordenação só é bem-formada quando os dois elementos coordenados são constituintes. E mais, constituintes do mesmo tipo.  Ainda há outros testes de constituintes que poderíamos aplicar, como, por exemplo, a interpolação. Esse teste consiste em introduzirmos um elemento “intruso” entre os sintagmas (elementos parentéticos, como sem dúvida, em geral, certamente, eu acho etc.). Por isso, podemos chamá-lo também de teste de intrusão. Vejamos: (3.11’c) [O João] sem dúvida [ama [a Maria]]. (3.11’d) [O João] [ama sem dúvida [a Maria]].  

 43 Se tentarmos inserir esse elemento intruso dentro de um sintagma nominal, o resultado será uma frase agramatical, como podemos ver abaixo:  (3.11’e) *[O sem dúvida João] [ama [a Maria]]. (3.11’f) *[O João] [ama [a sem dúvida Maria]].  Testes como esses ajudam a corroborarmos nossas intuições ao analisarmos sentenças de qualquer língua, além de facilitarem-nos a vida quando estamos em dúvida na representação de alguma sentença. Além disso, uma vez que já sabemos identificar e reconhecer os constituintes (ou sintagmas), fica mais claro entender o funcionamento de uma gramática sintagmática. De acordo com Nivette (1975: 18), A teoria dos constituintes imediatos era, no princípio, estritamente analítica, procurava descrever e explicar os fenômenos linguísticos, mas não produzi-los. Entretanto, para a elaboração da sua gramática gerativa, Chomsky pretendeu fundamentar-se em uma teoria linguística existente e considerou que, para fazê-lo, a teoria dos constituintes imediatos era a mais apropriada. A gramática que ele elaborou, a partir desta teoria, foi a Gramática Sintagmática (em inglês, “Phrase Structure Grammar”), que se baseia em um vocabulário determinado de símbolos e em certo número de regras de reescrever (grifos do autor). Já conhecemos alguns dos símbolos usados por Chomsky: S, SN, SV, Det, N e V. Esses símbolos são usados nas regras de reescrita (ou regras de reescrever, ou ainda regras sintagmáticas). E estas são as regras de reescrever que validam nossa sentença (3.11):  (a)  S à SN  SV (b)  SN à Det  N (c)  SV à V  SN  

 44 As regras de reescrever (a), (b) e (c) acima devem ser entendidas da seguinte maneira: um constituinte S irá se expandir em dois outros constituintes (ou nós): SN e SV. SN não é um constituinte terminal; a regra (b) mostra que ele deve também se expandir, em Det e N. Da mesma maneira, a regra (c) diz que o SV também não é um constituinte terminal: ele por sua vez irá gerar outros dois nós, V e SN. Se estivéssemos montando uma árvore sintática a partir dessas regras, efetuaríamos os seguintes passos, definidos pelas regras acima:  Regra (a)           S  Regra (b)  SN    SV       Regra (c)    Det  N    V  SN      Regra (b) novamente     Det    N  Além das regras sintagmáticas, existem também as regras de inserção lexical, que são responsáveis por introduzir os itens lexicais (as palavras) abaixo de cada símbolo respectivo. Veja as regras de inserção lexical utilizadas para a formação da sentença (3.11):  (d)  Det à o, a (e)  N à João, Maria (f)  V à ama  Essas regras (de reescrever e de inserção lexical) podem ser chamadas de gerativas, pois elas geram sentenças gramaticais a partir de instruções precisas e explícitas. Após a aplicação dessas regras, obtemos a estrutura de uma frase válida, ou gramatical, na língua definida pela 

 45 nossa gramática. A partir de todas essas regras, poderemos estruturar a sentença (3.11) em uma estrutura arbórea — ou marcador sintagmático — que nos permitirá visualizar claramente a organização hierárquica entre os constituintes, e suas relações de precedência e dominância.  De acordo com Radford (1981: 79), uma árvore sintática é um  conjunto de pontos (ou nós, para usar a terminologia técnica adequada), conectado por linhas, ou galhos. Os nós que ficam no final, ou na parte de baixo, de uma estrutura arbórea completa são chamados de nós terminais; os outros nós são chamados de não-terminais. Cada nó tem um nome, ou um rótulo. Os  nós não terminais ganham nomes, ou rótulos, de categorias (N, SN; V, SV etc.); os nós terminais (a menos que estejam vazios (…)) recebem rótulos de itens lexicais apropriados, quer dizer, palavras. Há dois tipos de relação entre um par de nós contido em uma mesma árvore sintática: precedência ou dominância (grifos do autor).  Podemos finalmente estruturar a árvore sintática da frase (3.11) a partir das regras (a-f), trabalhando como um parser top-down (que constrói uma sentença a partir de seu topo, até chegar ao nível das palavras). Aplicando a regra (a), obteremos:       S  SN  SV  Aplicando (b),                       SN          Det              N          Com a aplicação de (c), obtemos 

 46      SV                   V         SN  E, novamente, aplicando (b), que nos permite desenvolver o SN dominado imediatamente pelo SV, teremos nossa estrutura sintagmática completa:    S    SN  SV      Det         N     V           SN           Det  N  Aplicando-se, então, as regras de inserção lexical, obteremos a nossa sentença (3.11): S  SN  SV      Det         N     V       SN   Det  N        O      João  ama  a      Maria  Vejamos algumas noções importantes na organização hierárquica 

 47 das sentenças. A relação de precedência diz respeito à posição linear dos nós na estrutura arbórea: dizemos que um nó precede o outro se ele estiver à esquerda desse outro nó e entre eles não houver relação de dominância. Por exemplo, o SN (o João) precede o SV e precede o SN (a Maria) na representação acima. Já a relação de dominância pode ser expressa da seguinte forma: dizemos que “um nó X domina um nó Y se e somente se houver um caminho puramente descendente através da árvore de X para Y” PT (Borsley, 1999: 248). Essa noção remete-nos à dominância imediata, que é uma relação de dominância entre dois nós que estejam ligados imediatamente um ao outro através da relação de dominância. Por exemplo, na estrutura acima, a S domina todos os outros nós, mas domina imediatamente apenas o SN (o João) e o SV. É bem sabido, no entanto, que a gramática sintagmática apresenta uma série de limitações e precisa ser enriquecida com recursos adicionais. De acordo com a nossa pequena gramática acima, por exemplo, poderíamos gerar também as seguintes sentenças, claramente agramaticais:  (3.12) *A João ama a Maria. (3.13) *A João ama o Maria (3.14)  *O João ama o Maria.  Além disso, se expandíssemos as palavras da categoria N para João, Maria, livro, meninos, teríamos frases como as abaixo:  (3.15) O livro ama o João. (3.16) O livro ama a Maria. (3.17) *O meninos ama a Maria.  

 48 Da mesma forma, se ampliássemos a categoria V para ama, gosta, cai, chove, obteríamos algumas frases nitidamente agramaticais, como  (3.18) *O João gosta a Maria. (3.19) *O João cai a Maria. (3.20) *O João chove a Maria.  Por isso, teremos de adicionar alguns recursos às regras sintagmáticas e trabalhar com a descrição e classificação do léxico para implementar este tipo de gramática na linguagem Prolog. Neste ponto da leitura, é bem provável que nem tudo ainda esteja claro, mas muito sobre a implementação das regras sintagmáticas em Prolog será tratado com mais detalhe já na próxima seção. 3.2. Teoria computacional 3.2.1. Prolog Como vimos anteriormente, a linguagem de programação Prolog difere de outras linguagens mais convencionais, como Pascal, Fortran, C e outras. O Prolog é uma linguagem de programação declarativa, baseada na lógica matemática (já vimos também que o nome Prolog é a abreviação de PROgramming in LOGic, ou seja, “programando em lógica”). De acordo com Dougherty (1994: 36), “Prolog é uma abreviação de Programming in Logic porque, na maioria dos casos, o Prolog está tentando descobrir se uma afirmação é verdadeira ou falsa, ou está tentando encontrar alguma combinação de variáveis que torne uma afirmação verdadeira” (grifos do autor). Isso quer dizer que executar um programa em Prolog é fazer uma consulta à sua base de dados. E uma consulta nada mais é do que uma chamada de uma cláusula do programa, equivalendo a uma solicitação 

 49 para provar se o que pedimos é verdadeiro de acordo com a base de dados do programa. Segundo Lu & Mead (s.d.: 1), no paradigma do Prolog,  o programador especifica relações entre os valores dos dados (isso constitui um programa lógico) e então propõe questionamentos para o ambiente de execução do programa (geralmente um interpretador interativo) para verificar se certas relações se sustentam.PT  Mas essa discussão toda ainda parece muito abstrata. Vejamos como começar a fazer um programa simples em Prolog, para que possamos entender mais claramente o seu funcionamento5.  Para escrever um programa, devemos abrir um editor de textos, como o Bloco de Notas (ou Notepad), presente em todas as versões do MS Windows disponíveis no mercado. É no editor que desenvolveremos os programas que mais tarde serão rodados na plataforma do Prolog. Para começar, vamos escrever um programa bastante simples, mas que deixe suficientemente clara a natureza declarativa do Prolog, bem como a sua maneira de consultar a base de dados. Como dissemos anteriormente, o Prolog faz relações entre as informações de seu banco de dados e consulta essas informações para saber se uma afirmação é verdadeira ou falsa. Podemos partir de um programinha simples que trate das seguintes relações:  Sócrates é homem. O homem é mortal.   5 Os programas serão executados na versão SWI Prolog v. 4.0.7, que pode ser obtida gratuitamente na internet (como no site www.inf.pucrs.br/~flavio/, por exemplo). Todos os programas demonstrados aqui estão disponíveis na homepage da Editora (www.parabolaeditorial.com.br) e foram desenvolvidos nessa mesma versão do Prolog. Talvez agora já seja um bom momento de “baixar” o SWI Prolog e instalá-lo em seu computador. 

 50 Em notação Prolog, devemos escrever:  homem(socrates). mortal(X) :- homem(X).  Note que devemos escrever tudo em letras minúsculas e sempre colocar um ponto final no fim de cada linha. Na verdade, só podemos escrever com letras maiúsculas as variáveis, como veremos adiante.  A primeira linha do programa corresponde à nossa primeira premissa acima, a segunda linha corresponde à segunda premissa, conforme mostra a tabela 3.1:  Tabela 3.1: Tradução — Prolog x português   A primeira premissa (homem(socrates).) é o que chamamos em Prolog de fato. Os fatos são regras que, de certa forma, se autossatisfazem, ou seja, são dados sempre verdadeiros. Eles nunca apresentam variáveis e são explicitados em Prolog da seguinte maneira (na coluna da esquerda, temos fatos em Prolog; na coluna da direita, temos a sua interpretação em português): (1) homem(socrates).   Sócrates é um homem (2) x(y).     y é um x (3) professor(sergio).   Sérgio é um professor (4) numero(4).    4 é um número (5) numero(quatro).   Quatro é um número Etc. EM PROLOG EM PORTUGUÊS homem(socrates). Sócrates é homem. mortal(X) :- homem(X). O homem é mortal. 

 51  A segunda premissa em nosso exemplo (mortal(X) :- homem(X).) é uma regra em Prolog: ela apresenta uma variável (escrita sempre em letras maiúsculas) e uma relação de condicionalidade, expressa pelo operador “:-”. Ao contrário dos fatos, as regras consistem sempre de duas partes: a cabeça e o corpo:  mortal(X) :- homem(X). Cabeça     Corpo    Para que a cabeça da regra seja verdadeira, as condições expressas em seu corpo devem ser satisfeitas. A interpretação de uma regra desse estilo é bastante simples:  (6) a :- b.    “a” é verdadeiro se “b” é verdadeiro  (7) a :- b, c, d. “a” é verdadeiro se “b”, “c” e “d” forem verdadeiros  Isso nos leva a uma tradução mais refinada da regra em nosso programa acima:  (8) mortal(X) :- homem(X) “x” é mortal se for verdade que “x” é homem      Ou ainda:      Se “x” é homem, então “x” é mortal  

 52 A partir de nosso primeiro programa escrito em Prolog (mostrado aqui no quadro 3.1), podemos fazer as seguintes consultas no Prolog (quadro 3.2):  Quadro 3.1: Programa01.swi % Programa 01: Sócrates e a imortalidade   homem(socrates).  % Sócrates é homem.  mortal(X) :- homem(X). % É verdade que X é mortal se X for homem.   % Detalhe: sempre depois de cada linha, devemos colocar um ponto final. % Tudo o que for escrito depois do símbolo de porcentagem (%) não será lido pelo Prolog. Aqui é o espaço de escrevermos os comentários do programa, se os houver. % Como fizemos este programa? Em um editor de textos, simplesmente escrevemos as relações estudadas acima e o salvamos no diretório “default” do Prolog, com o nome de “programa01.swi”.   Quadro 3.2: Consultando o programa01.swi  Passo A  Passo B  Consulta 1  Consulta 2  Vejamos o que acabamos de fazer no quadro 3.2 logo acima. Primeiramente, carregamos o Prolog (dando dois cliques acima do ícone que designa o programa, ainda na plataforma Windows), o que resultou com que o programa fosse carregado (passo A). Depois, como mostra o Welcome to SWI-Prolog (Version 4.0.7) Copyright (c) 1990-2000 University of Amsterdam.  Copy policy: GPL-2 (see www.gnu.org)  For help, use ?- help(Topic). or ?- apropos(Word).  ?- [programa1].  % programa01 compiled 0.00 sec, 752 bytes  Yes ?-homem(socrates).  Yes ?-homem(X).  X = socrates  Yes ?- 

 53 passo B, chamamos o nosso programa (digitando seu nome entre colchetes, seguido de um ponto final: [programa01].) no prompt do Prolog, “?-”. Como o Prolog conseguiu abrir com sucesso o programa01, ele retornou um Yes logo abaixo.  Lembre-se de que todos os programas que fizermos com o Prolog devem ser salvos em um diretório default do Prolog, especificado pelo próprio usuário durante a instalação dessa linguagem. Em relação à extensão dos arquivos dos programas que desenvolvemos, optamos por adotar a extensão .swi, recomendada pelos próprios desenvolvedores do SWI Prolog. Outras extensões poderiam ser usadas (como .pro, por exemplo, também muito encontrada em programas desenvolvidos em Prolog), mas preferimos, por convenção, salvar nossos arquivos sempre com a extensão .swi.  Uma vez que o nosso programa tenha sido carregado com sucesso, começamos a fazer algumas consultas, ou queries (note que o que está escrito em negrito no quadro 3.2 é o nosso input, ou seja, aquilo que digitamos no Prolog; o que está em texto sem marcação é o que o programa nos mostra ou retorna como resposta. Adotaremos essa convenção daqui para frente). Há basicamente dois tipos de perguntas que podemos fazer para o Prolog: perguntas sim/não e perguntas-QU. As perguntas do tipo sim/não esperam uma resposta que seja justamente um sim ou um não, do tipo: A Maria ama o João?; Vai chover no final de semana? etc. Já as perguntas-QU (tradução literal do inglês, wh-questions) envolvem pronomes interrogativos, que frequentemente começam por qu (e, em inglês, wh), como quem, qual, quando etc. Veja estes exemplos de perguntas-QU: Quem ama o João?; Quando vai chover? etc. Na consulta 1, fizemos uma pergunta do tipo sim/não: perguntamos ao Prolog se é verdade que Sócrates é homem (homem(socrates).). O que o programa fez foi consultar a sua base de dados e verificar se este fato é verdadeiro de acordo com o seu 

 54 conhecimento. Como esta informação consta em seus dados (veja a primeira linha de nosso programa, no quadro 3.1), o Prolog retornou uma resposta afirmativa (Yes).  Curiosamente, se perguntássemos ao programa se Platão também é homem (homem(platao).), ele responderia com uma resposta negativa (No). Isso não quer dizer que Platão não seja um homem; apenas quer dizer que, entre as informações que estão acessíveis ao programa01, não consta nada sobre o fato de Platão ser homem ou não. Apesar de parecer trivial, essa ressalva é muito importante, e devemos mantê-la sempre em mente daqui para a frente. Uma outra observação de ordem prática: o Prolog retorna Yes ou No sempre duas linhas abaixo de nossas consultas. Por isso, o primeiro Yes é, como vimos, relativo ao sucesso do carregamento do programa01 (Passo B), e o segundo Yes (mais abaixo) refere-se à nossa consulta 1. Na consulta 2, demos um pouco mais de trabalho ao Prolog: perguntamos ao programa quem era homem de acordo com a sua base de dados (homem(X).), ou seja, fizemos uma pergunta-QU. Para isso, utilizamos uma variável — sempre uma letra maiúscula (na verdade, qualquer caracter ou sequência de caracteres maiúsculos). Para o programa01, o único homem é Sócrates (X = socrates). Nas perguntas-QU, sempre envolveremos variáveis, enquanto nas perguntas sim/não, iremos apenas perguntar se determinado fato é verdadeiro ou falso. Vejamos mais algumas consultas ao nosso programa:  Quadro 3.3: Consultando o programa01 novamente  Consulta 1 Consulta 2  Consulta 3  ?- homem(platao).  No ?- mortal(socrates).  Yes ?- mortal(X).  X = sócrates  Yes ?- 

 55 Na consulta 1, perguntamos ao programa se Platão era um homem (homem(platao).). Já sabíamos de antemão que o programa iria dizer que não, porque não demos a ele a informação sobre Platão em sua base de dados, a fim de que ele pudesse realizar sua consulta e nos retornar uma resposta afirmativa.  Na consulta 2, perguntamos se Sócrates era mortal (mortal(socrates).). É interessante notarmos que o programa não tem em sua base de dados exatamente essa informação. Quer dizer, consultando as informações do programa01, verificamos que há um fato que diz “Sócrates é homem” (homem(socrates).), mas não há nada que diga “Sócrates é mortal” (que deveria ser representado em Prolog por mortal(socrates).). Como o programa pôde então retornar uma resposta afirmativa à nossa consulta? Com base em que dados (e que raciocínio) o programa soube que Sócrates era mortal? Muito simples: através de relações entre diferentes informações que constam na sua base de dados. Reveja o programa01 acima antes de continuarmos (…). Se nosso leitor continua atento, ficou claro como o programa conseguiu responder afirmativamente à pergunta “O Sócrates é mortal?”. O que nosso programa fez foi tirar uma conclusão válida a partir de duas premissas verdadeiras, como expressa o silogismo categórico abaixo:  Sócrates é um homem.        homem(socrates). O homem é mortal.        mortal(X) :- homem(X). Logo Sócrates é mortal. Se X = socrates, então X = homem e X = mortal Lembre-se de que as letras maiúsculas representam variáveis no Prolog. Nosso programa usou um processo chamado de unificação de variáveis para responder à consulta. Seu primeiro passo foi verificar se 

 56 Sócrates era um homem. Isso é um fato do programa, uma verdade. Depois, ele tentou a unificação de homem(socrates) com homem(X). Dessa unificação, ele obteve que X = socrates. Ou seja, ele atribuiu o valor “socrates” à variável “X”. Por fim, ele fez o seguinte raciocínio: (a) se X é homem, então X é mortal; (b) se Sócrates é X, então Sócrates é homem; (c) se Sócrates é homem e o homem é mortal, logo o Sócrates é mortal. Voilà. Na consulta 3, propusemos uma pergunta-QU: perguntamos ao programa quem era mortal (mortal(X).). A partir de um raciocínio semelhante ao acima, porém inverso, o programa pôde nos responder que, de acordo com as informações que lhe estão disponíveis, o Sócrates é mortal. Dê uma olhada nos quadros acima e refaça o raciocínio do Prolog.  3.2.2. DCGs e parsing em Prolog Agora que já vimos um pouco da lógica de funcionamento do Prolog, vejamos como trabalhar na construção de parsers sintáticos, que reconheçam uma sentença como sendo pertencente a uma língua e, além disso, que atribuam a essa sentença a sua estrutura de constituintes, baseada nas teorias que estudamos na primeira parte deste capítulo. Na verdade, precisamos deixar claro que há diferentes maneiras de se trabalhar com parsers sintáticos, e diversas têm sido as alternativas de desenvolvimento de ferramentas de linguagem natural que tratem da sintaxe de uma língua6. Como confirmam Gazdar & Mellish (1989: vi-vii), linguistas computacionais têm, ao longo dos anos, adotado muitos formalismos gramaticais diferentes para usarem em seus parsers, às vezes, pegando-os emprestados da Linguística,  6 Ver, por exemplo, as propostas de Almeida et al. (2003), Bick (1996 e 2000), Dougherty (1994), Gazdar & Mellish (1989), Othero (2004), Pagani (2004), Pereira & Shieber (1987), entre outros. 

 57 às vezes desenvolvendo-os do zero para a proposta à mão. Mesmo hoje, há provavelmente duas dúzias ou mais de formalismos gramaticais distintos em uso em vários projetos de PLN ao redor do mundo. TP Para desenvolvermos nosso parser, utilizaremos um recurso chamado de DCG, presente em quase todas as versões de Prolog atualmente distribuídas. Seguiremos de perto as propostas vistas em Othero (2004) e Pagani (2004), partindo inclusive de muitos dados presentes nas gramáticas que esses autores propõem. As DCGs (Definite Clause Grammars) foram introduzidas primeiramente por Pereira & Warren (1980). Elas são “um formalismo para representação de gramáticas livres de contexto” (Vieira & Lima, 2001: 18). Graças a elas, podemos converter as regras de reescrita de maneira bastante simples e transparente para a notação em Prolog. Lembra-se, leitor, das regras (a), (b) e (c) que já estudamos anteriormente?  (a)  S à SN  SV (b)  SN à Det  N (c)  SV à V  SN  Essas regras podem ser implementadas em Prolog de maneira bastante simples:  (a1) s --> sn, sv.    (b1) sn --> det, n. (c1) sv --> v, sn.  Tudo o que tivemos de fazer foi escrever os rótulos dos constituintes em letras minúsculas (caso contrário, o Prolog os trataria 

 58 como variáveis), substituir a flecha “à” por “-->”, separar os constituintes à direita da flecha por uma vírgula e, finalmente, lembrar de colocar um ponto final no fim de cada regra. O que a DCG faz é converter essas regras, relativamente transparentes para o linguista, em notação do Prolog, sem que vejamos esse procedimento. O Prolog não opera diretamente com as regras sintagmáticas tais como em (a1), (b1) e (c1). Na verdade, “quando um programa escrito na notação DCG é carregado, suas regras são automaticamente traduzidas para um formato conhecido como diferença de listas” (Pagani, 2004: 11). Grosso modo, a DCG pode ser entendida, então, como um recurso que torna mais fácil ao linguista a implementação de regras sintagmáticas em Prolog. Por exemplo, as regras (a1), (b1) e (c1), que são muito similares às regras sintagmáticas com que estamos acostumados a lidar, serão traduzidas internamente para o Prolog como (a2), (b2) e (c2), respectivamente: (a2) s(L1, L) :- sn(L1, L2), sv(L2, L). (b2) sn(L1, L) :- det(L1, L2), n(L2, L). (c2) sv(L1, L) :- v(L1, L2), sn(L2, L). Graças ao recurso da DCG, podemos programar em Prolog de maneira bastante similar à notação convencionalmente utilizada em sintaxe (ao menos, na teoria que adotamos e estudamos aqui). Veremos mais adiante que também utilizaremos outras regras, como regras de inserção lexical e regras lexicais, que serão necessárias para dar conta de determinados fenômenos. Por ora, no entanto, poderíamos já escrever um programa que desse conta da análise de uma sentença como a seguinte:  (3.21) Zequinha lavou o carro.  

 59 Veja no quadro 3.4 um programa que nada mais é do que uma pequena amostra de gramática que dá conta dessa sentença.   Quadro 3.4: Programa02.swi  % Programa 02: Zequinha e o carro  % Regras Sintagmáticas s --> sn, sv. sn --> n. sn --> det, n. sv --> v, sn.  % Regras de Inserção Lexical det --> [o]. n --> [zequinha];[carro]. v --> [lavou].  % Lembre-se de que aquilo que escrevemos depois do sinal de porcentagem (%) não é lido pelo Prolog. Por isso, para facilitar nossa programação, podemos escrever alguns comentários e títulos ilustrativos ao longo da gramática, usando esse recurso.  O programa 02 deve aceitar a sentença (3.21) como sendo gramatical, uma vez que tanto a estrutura da sentença está de acordo com a sua base de dados, como os itens lexicais constam em seu “dicionário”. Vejamos algumas consultas ao programa 02. Quadro 3.5: Consultando o programa02 Welcome to SWI-Prolog (Version 4.0.7) Copyright (c) 1990-2000 University of Amsterdam.  Copy policy: GPL-2 (see www.gnu.org)  For help, use ?- help(Topic). or ?- apropos(Word).  ?-[programa02]. % programa02 compiled 0.01 sec, 1,820 bytes  Yes ?- s([zequinha,lavou,o,carro], []).  Yes. ?- 

 60  Na consulta acima, perguntamos ao programa se a sequência de palavras “Zequinha lavou o carro” era uma sentença da língua de acordo com a gramática e o léxico inscritos no programa02. Note que temos de usar uma série de notações para consultar o programa. Temos de (i) escrever todas as palavras em letras minúsculas; (ii) utilizar parênteses e colchetes; (iii) separar os vocábulos por vírgulas e (iv) colocar, ao lado do colchete com a nossa consulta, um duplo colchetes []. Em um parser que conte com uma interface gráfica, como o Grammar Play, por exemplo, nada disso é necessário. Como nosso objetivo aqui será desenvolver apenas a gramática em Prolog em si, e não um parser completo (quer dizer, que tenha uma gramática em Prolog e uma interface gráfica), temos de começar a nos acostumar com essa notação de consulta ao Prolog. Na consulta que fizemos no quadro 3.5, obtivemos a resposta afirmativa. Isso quer dizer que, de acordo com a gramática que escrevemos, a sequência “Zequinha lavou o carro” é uma sentença gramatical da língua. No entanto, utilizando o mesmo léxico, poderíamos propor o reconhecimento de outras sentenças, tanto gramaticais como agramaticais:  Quadro 3.6: Consultando o programa02 novamente Consulta 1 Consulta 2 Consulta 3 Consulta 4  ?- s([o,zequinha,lavou,o,carro], []).  Yes ?- s([o,carro,lavou,zequinha], []).  Yes ?- s([o,lavou,carro,zequinha], []).  No ?- s([nosso,parser,ficou,excelente], []).  No ?- 

 61  Na primeira consulta, perguntamos se a frase “O Zequinha lavou o carro” era gramatical. Como nosso programa apresenta duas regras para a descrição do SN (SN à det  N / SN à N), ele respondeu afirmativamente à nossa pergunta. Na segunda consulta, usamos uma frase gramatical (como vimos, de maneira sintaticamente estrita e estritamente sintática), porém absurda semântica ou pragmaticamente, o que resultou com que o programa nos retornasse outra vez uma resposta afirmativa, indicando que esta é uma sentença gramatical na língua, de acordo com a sua gramática. Na terceira consulta, experimentamos uma frase claramente agramatical (*O lavou carro Zequinha) e nosso programa a reconheceu como tal, retornando um No à consulta. Por fim, em nossa quarta consulta, perguntamos ao programa se a sentença “Nosso parser ficou excelente” é uma frase da língua, mas ele não soube reconhecê-la. Por que isso aconteceu? Por dois motivos: (a) as palavras dessa sentença não constam no léxico do programa e (b) essa sentença foge às regras gramaticais presentes em sua gramática. Falaremos mais sobre isso no próximo capítulo. 

