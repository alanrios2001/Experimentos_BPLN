CHAPTER
13RNNs and LSTMs
Time will explain.
Jane Austen, Persuasion
Language is an inherently temporal phenomenon. Spoken language is a sequence of
acoustic events over time, and we comprehend and produce both spoken and written
language as a sequential input stream. The temporal nature of language is reﬂected
in the metaphors we use; we talk of the ﬂow of conversations ,news feeds , and twitter
streams , all of which emphasize that language is a sequence that unfolds in time.
This chapter introduces a deep learning architecture, the recurrent neural net-
work (RNN) , and RNN variants like LSTMs, that offer a different way of represent-
ing time than feedforward and transformer networks. RNNs have a mechanism that
deals directly with the sequential nature of language, allowing them to handle the
temporal nature of language without the use of arbitrary ﬁxed-sized windows. The
recurrent network offers a new way to represent the prior context, in its recurrent
connections , allowing the model’s decision to depend on information from hundreds
of words in the past. We’ll see how to apply the model to the task of language mod-
eling, to text classiﬁcation tasks like sentiment analysis, and to sequence modeling
tasks like part-of-speech tagging.
13.1 Recurrent Neural Networks
A recurrent neural network (RNN) is any network that contains a cycle within its
network connections, meaning that the value of some unit is directly, or indirectly,
dependent on its own earlier outputs as an input. While powerful, such networks
are difﬁcult to reason about and to train. However, within the general class of recur-
rent networks there are constrained architectures that have proven to be extremely
effective when applied to language. In this section, we consider a class of recurrent
networks referred to as Elman Networks (Elman, 1990) or simple recurrent net-Elman
Networks
works . These networks are useful in their own right and serve as the basis for more
complex approaches like the Long Short-Term Memory (LSTM) networks discussed
later in this chapter. In this chapter when we use the term RNN we’ll be referring to
these simpler more constrained networks (although you will often see the term RNN
to mean any net with recurrent properties including LSTMs).
Fig. 13.1 illustrates the structure of an RNN. As with ordinary feedforward net-
works, an input vector representing the current input, xt, is multiplied by a weight
matrix and then passed through a non-linear activation function to compute the val-
ues for a layer of hidden units. This hidden layer is then used to calculate a cor-
responding output, yt. In a departure from our earlier window-based approach, se-
quences are processed by presenting one item at a time to the network. We’ll use

280 CHAPTER 13 • RNN S AND LSTM S
xthtyt
Figure 13.1 Simple recurrent neural network after Elman (1990). The hidden layer in-
cludes a recurrent connection as part of its input. That is, the activation value of the hidden
layer depends on the current input as well as the activation value of the hidden layer from the
previous time step.
subscripts to represent time, thus xtwill mean the input vector xat time t. The key
difference from a feedforward network lies in the recurrent link shown in the ﬁgure
with the dashed line. This link augments the input to the computation at the hidden
layer with the value of the hidden layer from the preceding point in time .
The hidden layer from the previous time step provides a form of memory, or
context, that encodes earlier processing and informs the decisions to be made at
later points in time. Critically, this approach does not impose a ﬁxed-length limit
on this prior context; the context embodied in the previous hidden layer can include
information extending back to the beginning of the sequence.
Adding this temporal dimension makes RNNs appear to be more complex than
non-recurrent architectures. But in reality, they’re not all that different. Given an
input vector and the values for the hidden layer from the previous time step, we’re
still performing the standard feedforward calculation introduced in Chapter 6. To
see this, consider Fig. 13.2 which clariﬁes the nature of the recurrence and how it
factors into the computation at the hidden layer. The most signiﬁcant change lies in
the new set of weights, U, that connect the hidden layer from the previous time step
to the current hidden layer. These weights determine how the network makes use of
past context in calculating the output for the current input. As with the other weights
in the network, these connections are trained via backpropagation.
+UVWyt
xththt-1
Figure 13.2 Simple recurrent neural network illustrated as a feedforward network. The
hidden layer ht−1from the prior time step is multiplied by weight matrix Uand then added
to the feedforward component from the current time step.
13.1.1 Inference in RNNs
Forward inference (mapping a sequence of inputs to a sequence of outputs) in an
RNN is nearly identical to what we’ve already seen with feedforward networks. To
compute an output ytfor an input xt, we need the activation value for the hidden
layer ht. To calculate this, we multiply the input xtwith the weight matrix W, and

13.1 • R ECURRENT NEURAL NETWORKS 281
the hidden layer from the previous time step ht−1with the weight matrix U. We
add these values together and pass them through a suitable activation function, g,
to arrive at the activation value for the current hidden layer, ht. Once we have the
values for the hidden layer, we proceed with the usual computation to generate the
output vector.
ht=g(Uht−1+Wx t) (13.1)
yt=f(Vht) (13.2)
Let’s refer to the input, hidden and output layer dimensions as din,dh, and dout
respectively. Given this, our three parameter matrices are: W∈Rdh×din,U∈Rdh×dh,
andV∈Rdout×dh.
We compute ytvia a softmax computation that gives a probability distribution
over the possible output classes.
yt=softmax (Vht) (13.3)
The fact that the computation at time trequires the value of the hidden layer from
time t−1 mandates an incremental inference algorithm that proceeds from the start
of the sequence to the end as illustrated in Fig. 13.3. The sequential nature of simple
recurrent networks can also be seen by unrolling the network in time as is shown in
Fig. 13.4. In this ﬁgure, the various layers of units are copied for each time step to
illustrate that they will have differing values over time. However, the various weight
matrices are shared across time.
function FORWARD RNN( x,network )returns output sequence y
h0←0
fori←1toLENGTH (x)do
hi←g(Uhi−1+Wx i)
yi←f(Vhi)
return y
Figure 13.3 Forward inference in a simple recurrent network. The matrices U,VandW
are shared across time, while new values for handyare calculated with each time step.
13.1.2 Training
As with feedforward networks, we’ll use a training set, a loss function, and back-
propagation to obtain the gradients needed to adjust the weights in these recurrent
networks. As shown in Fig. 13.2, we now have 3 sets of weights to update: W, the
weights from the input layer to the hidden layer, U, the weights from the previous
hidden layer to the current hidden layer, and ﬁnally V, the weights from the hidden
layer to the output layer.
Fig. 13.4 highlights two considerations that we didn’t have to worry about with
backpropagation in feedforward networks. First, to compute the loss function for
the output at time twe need the hidden layer from time t−1. Second, the hidden
layer at time tinﬂuences both the output at time tand the hidden layer at time t+1
(and hence the output and loss at t+1). It follows from this that to assess the error
accruing to ht, we’ll need to know its inﬂuence on both the current output as well as
the ones that follow .

282 CHAPTER 13 • RNN S AND LSTM S
UVWUVWUVW
x1x2x3y1y2y3
h1h3h2
h0
Figure 13.4 A simple recurrent neural network shown unrolled in time. Network layers are recalculated for
each time step, while the weights U,VandWare shared across all time steps.
Tailoring the backpropagation algorithm to this situation leads to a two-pass al-
gorithm for training the weights in RNNs. In the ﬁrst pass, we perform forward
inference, computing ht,yt, accumulating the loss at each step in time, saving the
value of the hidden layer at each step for use at the next time step. In the second
pass, we process the sequence in reverse, computing the required gradients as we go,
computing and saving the error term for use in the hidden layer for each step back-
ward in time. This general approach is commonly referred to as backpropagation
through time (Werbos 1974, Rumelhart et al. 1986, Werbos 1990).backpropaga-
tion through
timeFortunately, with modern computational frameworks and adequate computing
resources, there is no need for a specialized approach to training RNNs. As illus-
trated in Fig. 13.4, explicitly unrolling a recurrent network into a feedforward com-
putational graph eliminates any explicit recurrences, allowing the network weights
to be trained directly. In such an approach, we provide a template that speciﬁes the
basic structure of the network, including all the necessary parameters for the input,
output, and hidden layers, the weight matrices, as well as the activation and output
functions to be used. Then, when presented with a speciﬁc input sequence, we can
generate an unrolled feedforward network speciﬁc to that input, and use that graph
to perform forward inference or training via ordinary backpropagation.
For applications that involve much longer input sequences, such as speech recog-
nition, character-level processing, or streaming continuous inputs, unrolling an en-
tire input sequence may not be feasible. In these cases, we can unroll the input into
manageable ﬁxed-length segments and treat each segment as a distinct training item.

13.2 • RNN S AS LANGUAGE MODELS 283
13.2 RNNs as Language Models
Let’s see how to apply RNNs to the language modeling task. Recall from Chapter 3
that language models predict the next word in a sequence given some preceding
context. For example, if the preceding context is “Thanks for all the” and we want
to know how likely the next word is “ﬁsh” we would compute:
P(ﬁsh|Thanks for all the )
Language models give us the ability to assign such a conditional probability to every
possible next word, giving us a distribution over the entire vocabulary. We can also
assign probabilities to entire sequences by combining these conditional probabilities
with the chain rule:
P(w1:n) =n∏
i=1P(wi|w<i)
The n-gram language models of Chapter 3 compute the probability of a word given
counts of its occurrence with the n−1 prior words. The context is thus of size n−1.
For the feedforward language models of Chapter 6, the context is the window size.
RNN language models (Mikolov et al., 2010) process the input sequence one
word at a time, attempting to predict the next word from the current word and the
previous hidden state. RNNs thus don’t have the limited context problem that n-gram
models have, or the ﬁxed context that feedforward language models have, since the
hidden state can in principle represent information about all of the preceding words
all the way back to the beginning of the sequence. Fig. 13.5 sketches this difference
between a FFN language model and an RNN language model, showing that the
RNN language model uses ht−1, the hidden state from the previous time step, as a
representation of the past context.
VWethtUht-1ethtet-1et-2U       Wa)b)^yt
et-1^ytht-2WWet-2U
Figure 13.5 Simpliﬁed sketch of two LM architectures moving through a text, showing a
schematic context of three tokens: (a) a feedforward neural language model which has a ﬁxed
context input to the weight matrix W, (b) an RNN language model, in which the hidden state
ht−1summarizes the prior context.
13.2.1 Forward Inference in an RNN language model
Forward inference in a recurrent language model proceeds exactly as described in
Section 13.1.1. The input sequence X= [x1;...;xt;...;xN]consists of a series of

284 CHAPTER 13 • RNN S AND LSTM S
words each represented as a one-hot vector of size |V|×1, and the output predic-
tion,ˆ y, is a vector representing a probability distribution over the vocabulary. At
each step, the model uses the word embedding matrix Eto retrieve the embedding
for the current word, multiples it by the weight matrix W, and then adds it to the hid-
den layer from the previous step (weighted by weight matrix U) to compute a new
hidden layer. This hidden layer is then used to generate an output layer which is
passed through a softmax layer to generate a probability distribution over the entire
vocabulary. That is, at time t:
et=Ext (13.4)
ht=g(Uht−1+We t) (13.5)
ˆ yt=softmax (Vht) (13.6)
When we do language modeling with RNNs (and we’ll see this again in Chapter 8
with transformers), it’s convenient to make the assumption that the embedding di-
mension deand the hidden dimension dhare the same. So we’ll just call both of
these the model dimension d. So the embedding matrix Eis of shape [d×|V|], and
xtis a one-hot vector of shape [|V|×1]. The product etis thus of shape [d×1].W
andUare of shape [d×d], sohtis also of shape [d×1].Vis of shape [|V|×d],
so the result of Vhis a vector of shape [|V|×1]. This vector can be thought of as
a set of scores over the vocabulary given the evidence provided in h. Passing these
scores through the softmax normalizes the scores into a probability distribution. The
probability that a particular word kin the vocabulary is the next word is represented
byˆ yt[k], the kth component of ˆ yt:
P(wt+1=k|w1,..., wt) = ˆ yt[k] (13.7)
The probability of an entire sequence is just the product of the probabilities of each
item in the sequence, where we’ll use ˆ yi[wi]to mean the probability of the true word
wiat time step i.
P(w1:n) =n∏
i=1P(wi|w1:i−1) (13.8)
=n∏
i=1ˆ yi[wi] (13.9)
13.2.2 Training an RNN language model
To train an RNN as a language model, we use the same self-supervision (orself- self-supervision
training ) algorithm we saw in Section 7.5: we take a corpus of text as training
material and at each time step task the model to predict the next word. We call
such a model self-supervised because we don’t have to add any special gold labels
to the data; the natural sequence of words is its own supervision! We simply train
the model to minimize the error in predicting the true next word in the training
sequence, using cross-entropy as the loss function. Recall that the cross-entropy
loss measures the difference between a predicted probability distribution and the
correct distribution.
LCE=−∑
w∈Vyt[w]logˆyt[w] (13.10)

13.2 • RNN S AS LANGUAGE MODELS 285
InputEmbeddingsSoftmax overVocabulary
SolongandthanksforlongandthanksforNext wordall…Loss……RNNhyVh
<latexit sha1_base64="9tru+5ysH1zS9iUXRg/IsnxmpMA=">AAAB/XicbVDLSsNAFL3xWesr6lKQwSK4sSQi1WXRjcsK9gFNCZPpJB06yYSZiRBCcOOvuBFxo+Av+Av+jUnbTVsPDBzOOcO993gxZ0pb1q+xsrq2vrFZ2apu7+zu7ZsHhx0lEklomwguZM/DinIW0bZmmtNeLCkOPU673viu9LtPVComokedxnQQ4iBiPiNYF5Jrnlw4XATIGWGdpbmbOSHWIxlmXERBnldds2bVrQnQMrFnpAYztFzzxxkKkoQ00oRjpfq2FetBhqVmhNO86iSKxpiMcUCzyfY5OiukIfKFLF6k0USdy+FQqTT0imS5nFr0SvE/r59o/2aQsShONI3IdJCfcKQFKqtAQyYp0TwtCCaSFRsiMsISE10UVp5uLx66TDqXdbtRbzxc1Zq3sxIqcAyncA42XEMT7qEFbSDwAm/wCV/Gs/FqvBsf0+iKMftzBHMwvv8ADJKVcA==</latexit> log ˆylong<latexit sha1_base64="tuzkS/BeX/Xmg79qpWZlpeYDhtE=">AAAB/HicbVDLSsNAFL3xWesr6lKEwSK4sSQi1WXRjcsK9gFNCZPJpB06mYSZiRBC3PgrbkTcKPgN/oJ/Y9J209YDA4dzznDvPV7MmdKW9WusrK6tb2xWtqrbO7t7++bBYUdFiSS0TSIeyZ6HFeVM0LZmmtNeLCkOPU673viu9LtPVCoWiUedxnQQ4qFgASNYF5Jrnlw4PBoiZ4R1luZu5oRYj2SYYeHnedU1a1bdmgAtE3tGajBDyzV/HD8iSUiFJhwr1betWA8yLDUjnOZVJ1E0xmSMhzSbLJ+js0LyURDJ4gmNJupcDodKpaFXJMvd1KJXiv95/UQHN4OMiTjRVJDpoCDhSEeobAL5TFKieVoQTCQrNkRkhCUmuuirPN1ePHSZdC7rdqPeeLiqNW9nJVTgGE7hHGy4hibcQwvaQOAF3uATvoxn49V4Nz6m0RVj9ucI5mB8/wEiupTp</latexit> log ˆyand<latexit sha1_base64="0zdsmbBovZ+hafWZN7Hvufo85tU=">AAAB/3icbVDLSsNAFJ3UV62vqEs3g0VwY0lEqsuiG5cV7AOaEibTSTN0kgkzN0IIWbjxV9yIuFHwD/wF/8ak7aatBwYO55zh3nu8WHANlvVrVNbWNza3qtu1nd29/QPz8KirZaIo61AppOp7RDPBI9YBDoL1Y8VI6AnW8yZ3pd97YkpzGT1CGrNhSMYR9zklUEiuiS8cIcfYCQhkae5mTkggUGEGAYkmOs9rrlm3GtYUeJXYc1JHc7Rd88cZSZqELAIqiNYD24phmBEFnAqW15xEs5jQCRmzbLp/js8KaYR9qYoXAZ6qCzkSap2GXpEs19PLXin+5w0S8G+GGY/iBFhEZ4P8RGCQuCwDj7hiFERaEEIVLzbENCCKUCgqK0+3lw9dJd3Lht1sNB+u6q3beQlVdIJO0Tmy0TVqoXvURh1E0Qt6Q5/oy3g2Xo1342MWrRjzP8doAcb3H7Aall0=</latexit> log ˆythanks<latexit sha1_base64="D3c31Jvxp3QWPr2h4tzQWmeenDs=">AAAB/HicbVDLSsNAFL3xWesr6lKEwSK4sSQi1WXRjcsK9gFNCZPppB06yYSZiRBC3PgrbkTcKPgN/oJ/Y9Jm09YDA4dzznDvPV7EmdKW9WusrK6tb2xWtqrbO7t7++bBYUeJWBLaJoIL2fOwopyFtK2Z5rQXSYoDj9OuN7kr/O4TlYqJ8FEnER0EeBQynxGsc8k1Ty4cLkbIGWOdJpmbOgHWYxmkvpBZVnXNmlW3pkDLxC5JDUq0XPPHGQoSBzTUhGOl+rYV6UGKpWaE06zqxIpGmEzwiKbT5TN0lktDlM/LX6jRVJ3L4UCpJPDyZLGbWvQK8T+vH2v/ZpCyMIo1DclskB9zpAUqmkBDJinRPMkJJpLlGyIyxhITnfdVnG4vHrpMOpd1u1FvPFzVmrdlCRU4hlM4BxuuoQn30II2EHiBN/iEL+PZeDXejY9ZdMUo/xzBHIzvP0CJlP0=</latexit> log ˆyfor<latexit sha1_base64="PI3y1fb9LhumoVCQRh2+Y84dRkc=">AAAB/HicbVDLSsNAFL3xWesr6lKEwSK4sSQi1WXRjcsK9gFNCZPppB06yYSZiRBC3PgrbkTcKPgN/oJ/Y9Jm09YDA4dzznDvPV7EmdKW9WusrK6tb2xWtqrbO7t7++bBYUeJWBLaJoIL2fOwopyFtK2Z5rQXSYoDj9OuN7kr/O4TlYqJ8FEnER0EeBQynxGsc8k1Ty4cLkbIGWOdJpmbOgHWYxmkmPMsq7pmzapbU6BlYpekBiVarvnjDAWJAxpqwrFSfduK9CDFUjPCaVZ1YkUjTCZ4RNPp8hk6y6Uh8oXMX6jRVJ3L4UCpJPDyZLGbWvQK8T+vH2v/ZpCyMIo1DclskB9zpAUqmkBDJinRPMkJJpLlGyIyxhITnfdVnG4vHrpMOpd1u1FvPFzVmrdlCRU4hlM4BxuuoQn30II2EHiBN/iEL+PZeDXejY9ZdMUo/xzBHIzvPyumlO8=</latexit> log ˆyall
e
Figure 13.6 Training RNNs as language models.
In the case of language modeling, the correct distribution ytcomes from knowing the
next word. This is represented as a one-hot vector corresponding to the vocabulary
where the entry for the actual next word is 1, and all the other entries are 0. Thus,
the cross-entropy loss for language modeling is determined by the probability the
model assigns to the correct next word. So at time tthe CE loss is the negative log
probability the model assigns to the next word in the training sequence.
LCE(ˆyt,yt) =−logˆyt[wt+1] (13.11)
Thus at each word position tof the input, the model takes as input the correct word wt
together with ht−1, encoding information from the preceding w1:t−1, and uses them
to compute a probability distribution over possible next words so as to compute the
model’s loss for the next token wt+1. Then we move to the next word, we ignore
what the model predicted for the next word and instead use the correct word wt+1
along with the prior history encoded to estimate the probability of token wt+2. This
idea that we always give the model the correct history sequence to predict the next
word (rather than feeding the model its best case from the previous time step) is
called teacher forcing . teacher forcing
The weights in the network are adjusted to minimize the average CE loss over
the training sequence via gradient descent. Fig. 13.6 illustrates this training regimen.
13.2.3 Weight Tying
Careful readers may have noticed that the input embedding matrix Eand the ﬁnal
layer matrix V, which feeds the output softmax, are quite similar.
The columns of Erepresent the word embeddings for each word in the vocab-
ulary learned during the training process with the goal that words that have similar
meaning and function will have similar embeddings. And, since when we use RNNs
for language modeling we make the assumption that the embedding dimension and
the hidden dimension are the same (= the model dimension d), the embedding ma-
trixEhas shape [d×|V|]. And the ﬁnal layer matrix Vprovides a way to score
the likelihood of each word in the vocabulary given the evidence present in the ﬁnal
hidden layer of the network through the calculation of Vh.Vis of shape [|V|×d].
That is, is, the rows of Vare shaped like a transpose of E, meaning that Vprovides

286 CHAPTER 13 • RNN S AND LSTM S
asecond set of learned word embeddings.
Instead of having two sets of embedding matrices, language models use a single
embedding matrix, which appears at both the input and softmax layers. That is,
we dispense with Vand use Eat the start of the computation and E⊺(because the
shape of Vis the transpose of Eat the end. Using the same matrix (transposed) in
two places is called weight tying .1The weight-tied equations for an RNN language weight tying
model then become:
et=Ext (13.12)
ht=g(Uht−1+We t) (13.13)
ˆ yt=softmax (E⊺ht) (13.14)
In addition to providing improved model perplexity, this approach signiﬁcantly re-
duces the number of parameters required for the model.
13.3 RNNs for other NLP tasks
Now that we’ve seen the basic RNN architecture, let’s consider how to apply it to
three types of NLP tasks: sequence classiﬁcation tasks like sentiment analysis and
topic classiﬁcation, sequence labeling tasks like part-of-speech tagging, and text
generation tasks, including with a new architecture called the encoder-decoder .
13.3.1 Sequence Labeling
In sequence labeling, the network’s task is to assign a label chosen from a small
ﬁxed set of labels to each element of a sequence. One classic sequence labeling
tasks is part-of-speech (POS) tagging (assigning grammatical tags like NOUN and
VERB to each word in a sentence). We’ll discuss part-of-speech tagging in detail
in Chapter 17, but let’s give a motivating example here. In an RNN approach to
sequence labeling, inputs are word embeddings and the outputs are tag probabilities
generated by a softmax layer over the given tagset, as illustrated in Fig. 13.7.
In this ﬁgure, the inputs at each time step are pretrained word embeddings cor-
responding to the input tokens. The RNN block is an abstraction that represents
an unrolled simple recurrent network consisting of an input layer, hidden layer, and
output layer at each time step, as well as the shared U,VandWweight matrices
that comprise the network. The outputs of the network at each time step represent
the distribution over the POS tagset generated by a softmax layer.
To generate a sequence of tags for a given input, we run forward inference over
the input sequence and select the most likely tag from the softmax at each step. Since
we’re using a softmax layer to generate the probability distribution over the output
tagset at each time step, we will again employ the cross-entropy loss during training.
13.3.2 RNNs for Sequence Classiﬁcation
Another use of RNNs is to classify entire sequences rather than the tokens within
them. This is the set of tasks commonly called text classiﬁcation , like sentiment
analysis or spam detection, in which we classify a text into two or three classes
(like positive or negative), as well as classiﬁcation tasks with a large number of
1We also do this for transformers (Chapter 8) where it’s common to call E⊺theunembedding matrix .

13.3 • RNN S FOR OTHER NLP TASKS 287
JanetwillbackthebillNNDTVBMDNNPArgmax
EmbeddingsWordsehVhyRNNLayer(s)Softmax overtags
Figure 13.7 Part-of-speech tagging as sequence labeling with a simple RNN. The goal of
part-of-speech (POS) tagging is to assign a grammatical label to each word in a sentence,
drawn from a predeﬁned set of tags. (The tags for this sentence include NNP (proper noun),
MD (modal verb) and others; we’ll give a complete description of the task of part-of-speech
tagging in Chapter 17.) Pre-trained word embeddings serve as inputs and a softmax layer
provides a probability distribution over the part-of-speech tags as output at each time step.
categories, like document-level topic classiﬁcation, or message routing for customer
service applications.
To apply RNNs in this setting, we pass the text to be classiﬁed through the RNN
a word at a time generating a new hidden layer representation at each time step.
We can then take the hidden layer for the last token of the text, hn, to constitute a
compressed representation of the entire sequence. We can pass this representation
hnto a feedforward network that chooses a class via a softmax over the possible
classes. Fig. 13.8 illustrates this approach.
x1
RNNhnx2x3xnSoftmaxFFN
Figure 13.8 Sequence classiﬁcation using a simple RNN combined with a feedforward net-
work. The ﬁnal hidden state from the RNN is used as the input to a feedforward network that
performs the classiﬁcation.
Note that in this approach we don’t need intermediate outputs for the words in
the sequence preceding the last element. Therefore, there are no loss terms associ-
ated with those elements. Instead, the loss function used to train the weights in the
network is based entirely on the ﬁnal text classiﬁcation task. The output from the
softmax output from the feedforward classiﬁer together with a cross-entropy loss

288 CHAPTER 13 • RNN S AND LSTM S
drives the training. The error signal from the classiﬁcation is backpropagated all the
way through the weights in the feedforward classiﬁer through, to its input, and then
through to the three sets of weights in the RNN as described earlier in Section 13.1.2.
The training regimen that uses the loss from a downstream application to adjust the
weights all the way through the network is referred to as end-to-end training .end-to-end
training
Another option, instead of using just the hidden state of the last token hnto
represent the whole sequence, is to use some sort of pooling function of all the pooling
hidden states hifor each word iin the sequence. For example, we can create a
representation that pools all the nhidden states by taking their element-wise mean:
hmean=1
nn∑
i=1hi (13.15)
Or we can take the element-wise max; the element-wise max of a set of nvectors is
a new vector whose kth element is the max of the kth elements of all the nvectors.
The long contexts of RNNs makes it quite difﬁcult to successfully backpropagate
error all the way through the entire input; we’ll talk about this problem, and some
standard solutions, in Section 13.5.
13.3.3 Generation with RNN-Based Language Models
RNN-based language models can also be used to generate text, Text generation,
along with image generation and code generation, constitute a new area of AI that
is often called generative AI . Those of you who have already read Chapter 7 and
Chapter 8 will have already seen this, but we reintroduce it here for those who are
reading in a different order.
Recall back in Chapter 3 we saw how to generate text from an n-gram language
model by adapting a sampling technique suggested at about the same time by Claude
Shannon (Shannon, 1951) and the psychologists George Miller and Jennifer Self-
ridge (Miller and Selfridge, 1950). We ﬁrst randomly sample a word to begin a
sequence based on its suitability as the start of a sequence. We then continue to
sample words conditioned on our previous choices until we reach a pre-determined
length, or an end of sequence token is generated.
Today, this approach of using a language model to incrementally generate words
by repeatedly sampling the next word conditioned on our previous choices is called
autoregressive generation orcausal LM generation . The procedure is basicallyautoregressive
generation
the same as that described on page 48, but adapted to a neural context:
• Sample a word in the output from the softmax distribution that results from
using the beginning of sentence marker, <s>, as the ﬁrst input.
• Use the word embedding for that ﬁrst word as the input to the network at the
next time step, and then sample the next word in the same fashion.
• Continue generating until the end of sentence marker, </s> , is sampled or a
ﬁxed length limit is reached.
Technically an autoregressive model is a model that predicts a value at time tbased
on a linear function of the previous values at times t−1,t−2, and so on. Although
language models are not linear (since they have many layers of non-linearities), we
loosely refer to this generation technique as autoregressive generation since the
word generated at each time step is conditioned on the word selected by the network
from the previous step. Fig. 13.9 illustrates this approach. In this ﬁgure, the details
of the RNN’s hidden layers and recurrent connections are hidden within the blue
block.

13.4 • S TACKED AND BIDIRECTIONAL RNN ARCHITECTURES 289
This simple architecture underlies state-of-the-art approaches to applications
such as machine translation, summarization, and question answering. The key to
these approaches is to prime the generation component with an appropriate context.
That is, instead of simply using <s> to get things started we can provide a richer
task-appropriate context; for translation the context is the sentence in the source
language; for summarization it’s the long text we want to summarize.
Solong
<s>and
Solongand?Sampled WordSoftmaxEmbeddingInput WordRNN
Figure 13.9 Autoregressive generation with an RNN-based neural language model.
13.4 Stacked and Bidirectional RNN architectures
Recurrent networks are quite ﬂexible. By combining the feedforward nature of un-
rolled computational graphs with vectors as common inputs and outputs, complex
networks can be treated as modules that can be combined in creative ways. This
section introduces two of the more common network architectures used in language
processing with RNNs.
13.4.1 Stacked RNNs
In our examples thus far, the inputs to our RNNs have consisted of sequences of
word or character embeddings (vectors) and the outputs have been vectors useful for
predicting words, tags or sequence labels. However, nothing prevents us from using
the entire sequence of outputs from one RNN as an input sequence to another one.
Stacked RNNs consist of multiple networks where the output of one layer serves as Stacked RNNs
the input to a subsequent layer, as shown in Fig. 13.10.
Stacked RNNs generally outperform single-layer networks. One reason for this
success seems to be that the network induces representations at differing levels of
abstraction across layers. Just as the early stages of the human visual system detect
edges that are then used for ﬁnding larger regions and shapes, the initial layers of
stacked networks can induce representations that serve as useful abstractions for
further layers—representations that might prove difﬁcult to induce in a single RNN.
The optimal number of stacked RNNs is speciﬁc to each application and to each
training set. However, as the number of stacks is increased the training costs rise

290 CHAPTER 13 • RNN S AND LSTM S
y1y2y3yn
x1x2x3xn
RNN 1
RNN 2
 RNN 3
Figure 13.10 Stacked recurrent networks. The output of a lower level serves as the input
to higher levels with the output of the last network serving as the ﬁnal output.
quickly.
13.4.2 Bidirectional RNNs
The RNN uses information from the left (prior) context to make its predictions at
time t. But in many applications we have access to the entire input sequence; in
those cases we would like to use words from the context to the right of t. One way
to do this is to run two separate RNNs, one left-to-right, and one right-to-left, and
concatenate their representations.
In the left-to-right RNNs we’ve discussed so far, the hidden state at a given time
trepresents everything the network knows about the sequence up to that point. The
state is a function of the inputs x1,...,xtand represents the context of the network to
the left of the current time.
hf
t=RNN forward (x1,...,xt) (13.16)
This new notation hf
tsimply corresponds to the normal hidden state at time t, repre-
senting everything the network has gleaned from the sequence so far.
To take advantage of context to the right of the current input, we can train an
RNN on a reversed input sequence. With this approach, the hidden state at time t
represents information about the sequence to the right of the current input:
hb
t=RNN backward (xt,...xn) (13.17)
Here, the hidden state hb
trepresents all the information we have discerned about the
sequence from tto the end of the sequence.
Abidirectional RNN (Schuster and Paliwal, 1997) combines two independentbidirectional
RNN
RNNs, one where the input is processed from the start to the end, and the other from
the end to the start. We then concatenate the two representations computed by the
networks into a single vector that captures both the left and right contexts of an input
at each point in time. Here we use either the semicolon ”;” or the equivalent symbol
⊕to mean vector concatenation:
ht= [hf
t;hb
t]
=hf
t⊕hb
t (13.18)

13.5 • T HELSTM 291
Fig. 13.11 illustrates such a bidirectional network that concatenates the outputs of
the forward and backward pass. Other simple ways to combine the forward and
backward contexts include element-wise addition or multiplication. The output at
each step in time thus captures information to the left and to the right of the current
input. In sequence labeling applications, these concatenated outputs can serve as the
basis for a local labeling decision.
RNN 2 
RNN 1x1y2y1y3ynconcatenatedoutputs
x2x3xn
Figure 13.11 A bidirectional RNN. Separate models are trained in the forward and back-
ward directions, with the output of each model at each time point concatenated to represent
the bidirectional state at that time point.
Bidirectional RNNs have also proven to be quite effective for sequence classi-
ﬁcation. Recall from Fig. 13.8 that for sequence classiﬁcation we used the ﬁnal
hidden state of the RNN as the input to a subsequent feedforward classiﬁer. A dif-
ﬁculty with this approach is that the ﬁnal state naturally reﬂects more information
about the end of the sentence than its beginning. Bidirectional RNNs provide a sim-
ple solution to this problem; as shown in Fig. 13.12, we simply combine the ﬁnal
hidden states from the forward and backward passes (for example by concatenation)
and use that as input for follow-on processing.
13.5 The LSTM
In practice, it is quite difﬁcult to train RNNs for tasks that require a network to make
use of information distant from the current point of processing. Despite having ac-
cess to the entire preceding sequence, the information encoded in hidden states tends
to be fairly local, more relevant to the most recent parts of the input sequence and
recent decisions. Yet distant information is critical to many language applications.
Consider the following example in the context of language modeling.
(13.19) The ﬂights the airline was canceling were full.
Assigning a high probability to wasfollowing airline is straightforward since airline
provides a strong local context for the singular agreement. However, assigning an
appropriate probability to were is quite difﬁcult, not only because the plural ﬂights
is quite distant, but also because the singular noun airline is closer in the intervening

292 CHAPTER 13 • RNN S AND LSTM S
RNN 2 
RNN 1x1x2x3xnhn→h1←hn→SoftmaxFFNh1←
Figure 13.12 A bidirectional RNN for sequence classiﬁcation. The ﬁnal hidden units from
the forward and backward passes are combined to represent the entire sequence. This com-
bined representation serves as input to the subsequent classiﬁer.
context. Ideally, a network should be able to retain the distant information about
plural ﬂights until it is needed, while still processing the intermediate parts of the
sequence correctly.
One reason for the inability of RNNs to carry forward critical information is that
the hidden layers, and, by extension, the weights that determine the values in the hid-
den layer, are being asked to perform two tasks simultaneously: provide information
useful for the current decision, and updating and carrying forward information re-
quired for future decisions.
A second difﬁculty with training RNNs arises from the need to backpropagate
the error signal back through time. Recall from Section 13.1.2 that the hidden layer
at time tcontributes to the loss at the next time step since it takes part in that calcula-
tion. As a result, during the backward pass of training, the hidden layers are subject
to repeated multiplications, as determined by the length of the sequence. A frequent
result of this process is that the gradients are eventually driven to zero, a situation
called the vanishing gradients problem.vanishing
gradients
To address these issues, more complex network architectures have been designed
to explicitly manage the task of maintaining relevant context over time, by enabling
the network to learn to forget information that is no longer needed and to remember
information required for decisions still to come.
The most commonly used such extension to RNNs is the long short-term mem-
ory(LSTM) network (Hochreiter and Schmidhuber, 1997). LSTMs divide the con-long short-term
memory
text management problem into two subproblems: removing information no longer
needed from the context, and adding information likely to be needed for later de-
cision making. The key to solving both problems is to learn how to manage this
context rather than hard-coding a strategy into the architecture. LSTMs accomplish
this by ﬁrst adding an explicit context layer to the architecture (in addition to the
usual recurrent hidden layer), and through the use of specialized neural units that
make use of gates to control the ﬂow of information into and out of the units that

13.5 • T HELSTM 293
comprise the network layers. These gates are implemented through the use of addi-
tional weights that operate sequentially on the input, and previous hidden layer, and
previous context layers.
The gates in an LSTM share a common design pattern; each consists of a feed-
forward layer, followed by a sigmoid activation function, followed by a pointwise
multiplication with the layer being gated. The choice of the sigmoid as the activation
function arises from its tendency to push its outputs to either 0 or 1. Combining this
with a pointwise multiplication has an effect similar to that of a binary mask. Values
in the layer being gated that align with values near 1 in the mask are passed through
nearly unchanged; values corresponding to lower values are essentially erased.
The ﬁrst gate we’ll consider is the forget gate . The purpose of this gate is forget gate
to delete information from the context that is no longer needed. The forget gate
computes a weighted sum of the previous state’s hidden layer and the current in-
put and passes that through a sigmoid. This mask is then multiplied element-wise
by the context vector to remove the information from context that is no longer re-
quired. Element-wise multiplication of two vectors (represented by the operator ⊙,
and sometimes called the Hadamard product ) is the vector of the same dimension
as the two input vectors, where each element iis the product of element iin the two
input vectors:
ft=σ(Ufht−1+Wfxt) (13.20)
kt=ct−1⊙ft (13.21)
The next task is to compute the actual information we need to extract from the previ-
ous hidden state and current inputs—the same basic computation we’ve been using
for all our recurrent networks.
gt=tanh(Ught−1+Wgxt) (13.22)
Next, we generate the mask for the add gate to select the information to add to the add gate
current context.
it=σ(Uiht−1+Wixt) (13.23)
jt=gt⊙it (13.24)
Next, we add this to the modiﬁed context vector to get our new context vector.
ct=jt+kt (13.25)
The ﬁnal gate we’ll use is the output gate which is used to decide what informa- output gate
tion is required for the current hidden state (as opposed to what information needs
to be preserved for future decisions).
ot=σ(Uoht−1+Woxt) (13.26)
ht=ot⊙tanh(ct) (13.27)
Fig. 13.13 illustrates the complete computation for a single LSTM unit. Given the
appropriate weights for the various gates, an LSTM accepts as input the context
layer, and hidden layer from the previous time step, along with the current input
vector. It then generates updated context and hidden vectors as output.
It is the hidden state, ht, that provides the output for the LSTM at each time step.
This output can be used as the input to subsequent layers in a stacked RNN, or at the
ﬁnal layer of a network htcan be used to provide the ﬁnal output of the LSTM.

294 CHAPTER 13 • RNN S AND LSTM S
+
xtht-1cthtcthtct-1ht-1xttanh
+σtanhσσ+++igf
o㽋㽋㽋LSTMct-1
Figure 13.13 A single LSTM unit displayed as a computation graph. The inputs to each unit consists of the
current input, x, the previous hidden state, ht−1, and the previous context, ct−1. The outputs are a new hidden
state, htand an updated context, ct.
h
xxtxtht-1htht
ct-1ct
ht-1(b)(a)(c)⌃gza⌃gzLSTMUnita
Figure 13.14 Basic neural units used in feedforward, simple recurrent networks (SRN),
and long short-term memory (LSTM).
13.5.1 Gated Units, Layers and Networks
The neural units used in LSTMs are obviously much more complex than those used
in basic feedforward networks. Fortunately, this complexity is encapsulated within
the basic processing units, allowing us to maintain modularity and to easily experi-
ment with different architectures. To see this, consider Fig. 13.14 which illustrates
the inputs and outputs associated with each kind of unit.
At the far left, (a) is the basic feedforward unit where a single set of weights and
a single activation function determine its output, and when arranged in a layer there
are no connections among the units in the layer. Next, (b) represents the unit in a
simple recurrent network. Now there are two inputs and an additional set of weights
to go with it. However, there is still a single activation function and output.
The increased complexity of the LSTM units is encapsulated within the unit
itself. The only additional external complexity for the LSTM over the basic recurrent
unit (b) is the presence of the additional context vector as an input and output.
This modularity is key to the power and widespread applicability of LSTM units.
LSTM units (or other varieties, like GRUs) can be substituted into any of the network
architectures described in Section 13.4. And, as with simple RNNs, multi-layered

13.6 • S UMMARY : COMMON RNN NLP A RCHITECTURES 295
networks making use of gated units can be unrolled into deep feedforward networks
and trained in the usual fashion with backpropagation. In practice, therefore, LSTMs
rather than RNNs have become the standard unit for any modern system that makes
use of recurrent networks.
13.6 Summary: Common RNN NLP Architectures
We’ve now introduced the RNN, seen advanced components like stacking multiple
layers and using the LSTM version, and seen how the RNN can be applied to various
tasks. Let’s take a moment to summarize the architectures for these applications.
Fig. 13.15 shows the three architectures we’ve discussed so far: sequence la-
beling, sequence classiﬁcation, and language modeling. In sequence labeling (for
example for part of speech tagging), we train a model to produce a label for each
input word or token. In sequence classiﬁcation, for example for sentiment analysis,
we ignore the output for each token, and only take the value from the end of the
sequence (and similarly the model’s training signal comes from backpropagation
from that last token). In language modeling, we train the model to predict the next
word at each token step. In the next section we’ll introduce a fourth architecture, the
encoder-decoder .
…Encoder RNNDecoder RNNContext…
x1x2xny1y2ym…RNNx1x2xn…y1y2yn…RNNx1x2xny
…RNNx1x2xt-1…x2x3xta) sequence labeling b) sequence classification 
c) language modelingd) encoder-decoder
Figure 13.15 Four architectures for NLP tasks. In sequence labeling (POS or named entity tagging) we map
each input token xito an output token yi. In sequence classiﬁcation we map the entire input sequence to a single
class. In language modeling we output the next token conditioned on previous tokens. In the encoder model we
have two separate RNN models, one of which maps from an input sequence xto an intermediate representation
we call the context , and a second of which maps from the context to an output sequence y.

296 CHAPTER 13 • RNN S AND LSTM S
13.7 The Encoder-Decoder Model with RNNs
In this section we introduce the encoder-decoder model, which is used when we are
taking an input sequence and translating it to an output sequence that is of a different
length than the input, and doesn’t align with it in a word-to-word way.
Those of you who already read Chapter 12 will have already seen this model in
the transformer architecture, and its application to machine translation, but we intro-
duce this architecture again here for those who come to the concepts in a different
order and are reading about RNNs before transformers.
Recall that in the sequence labeling task, we have two sequences, but they are
the same length (for example in part-of-speech tagging each token gets an associated
tag), each input is associated with a speciﬁc output, and the labeling for that output
takes mostly local information. Thus deciding whether a word is a verb or a noun,
we look mostly at the word and the neighboring words.
By contrast, encoder-decoder models are used especially for tasks like machine
translation, where the input sequence and output sequence can have different lengths
and the mapping between a token in the input and a token in the output can be very
indirect (in some languages the verb appears at the beginning of the sentence; in
other languages at the end). We introduced machine translation in Chapter 12, but
for now we’ll just point out that the mapping for a sentence in English to a sentence
in Tagalog or Yoruba can have very different numbers of words, and the words can
be in a very different order.
Encoder-decoder networks, sometimes called sequence-to-sequence networks,encoder-
decoder
are models capable of generating contextually appropriate, arbitrary length, output
sequences given an input sequence. Encoder-decoder networks have been applied
to a very wide range of applications including summarization, question answering,
and dialogue, but they are particularly popular for machine translation.
The key idea underlying these networks is the use of an encoder network that
takes an input sequence and creates a contextualized representation of it, often called
thecontext . This representation is then passed to a decoder which generates a task-
speciﬁc output sequence. Fig. 13.16 illustrates the architecture.
…EncoderDecoderContext…
x1x2xny1y2ym
Figure 13.16 The encoder-decoder architecture. The context is a function of the hidden
representations of the input, and may be used by the decoder in a variety of ways.
Encoder-decoder networks consist of three conceptual components:
1. An encoder that accepts an input sequence, x1:n, and generates a correspond-
ing sequence of contextualized representations, h1:n. LSTMs, convolutional
networks, and transformers can all be employed as encoders.
2. A context vector ,c, which is a function of h1:n, and conveys the essence of
the input to the decoder.

13.7 • T HEENCODER -DECODER MODEL WITH RNN S297
3. A decoder , which accepts cas input and generates an arbitrary length se-
quence of hidden states h1:m, from which a corresponding sequence of output
states y1:m, can be obtained. Just as with encoders, decoders can be realized
by any kind of sequence architecture.
In this section we’ll describe an encoder-decoder network based on a pair of
RNNs, but we’ll see in Chapter 12 how to apply them to transformers as well. We’ll
build up the equations for encoder-decoder models by starting with the conditional
RNN language model p(y), the probability of a sequence y.
Recall that in any language model, we can break down the probability as follows:
p(y) = p(y1)p(y2|y1)p(y3|y1,y2)...p(ym|y1,...,ym−1) (13.28)
In RNN language modeling, at a particular time t, we pass the preﬁx of t−1
tokens through the language model, using forward inference to produce a sequence
of hidden states, ending with the hidden state corresponding to the last word of
the preﬁx. We then use the ﬁnal hidden state of the preﬁx as our starting point to
generate the next token.
More formally, if gis an activation function like tanh or ReLU, a function of
the input at time tand the hidden state at time t−1, and the softmax is over the
set of possible vocabulary items, then at time tthe output ytand hidden state htare
computed as:
ht=g(ht−1,xt) (13.29)
ˆ yt=softmax (ht) (13.30)
We only have to make one slight change to turn this language model with au-
toregressive generation into an encoder-decoder model that is a translation model
that can translate from a source text in one language to a target text in a second:
add a sentence separation marker at the end of the source text, and then simplysentence
separation
concatenate the target text.
Let’s use<s>for our sentence separator token, and let’s think about translating
an English source text (“the green witch arrived”), to a Spanish sentence (“ lleg´o
la bruja verde ” (which can be glossed word-by-word as ‘arrived the witch green’).
We could also illustrate encoder-decoder models with a question-answer pair, or a
text-summarization pair.
Let’s use xto refer to the source text (in this case in English) plus the separator
token<s>, and yto refer to the target text y(in this case in Spanish). Then an
encoder-decoder model computes the probability p(y|x)as follows:
p(y|x) = p(y1|x)p(y2|y1,x)p(y3|y1,y2,x)...p(ym|y1,...,ym−1,x)(13.31)
Fig. 13.17 shows the setup for a simpliﬁed version of the encoder-decoder model
(we’ll see the full model, which requires the new concept of attention , in the next
section).
Fig. 13.17 shows an English source text (“the green witch arrived”), a sentence
separator token ( <s>, and a Spanish target text (“ lleg´o la bruja verde ”). To trans-
late a source text, we run it through the network performing forward inference to
generate hidden states until we get to the end of the source. Then we begin autore-
gressive generation, asking for a word in the context of the hidden layer from the
end of the source input as well as the end-of-sentence marker. Subsequent words
are conditioned on the previous hidden state and the embedding for the last word
generated.

298 CHAPTER 13 • RNN S AND LSTM S
Source TextTarget Text
hnembeddinglayerhiddenlayer(s)softmaxthegreenllegó
witcharrived<s>llególa
labruja
brujaverde
verde</s>(output of source is ignored)
Separator
Figure 13.17 Translating a single sentence (inference time) in the basic RNN version of encoder-decoder ap-
proach to machine translation. Source and target sentences are concatenated with a separator token in between,
and the decoder uses context information from the encoder’s last hidden state.
Let’s formalize and generalize this model a bit in Fig. 13.18. (To help keep
things straight, we’ll use the superscripts eanddwhere needed to distinguish the
hidden states of the encoder and the decoder.) The elements of the network on the
left process the input sequence xand comprise the encoder . While our simpliﬁed
ﬁgure shows only a single network layer for the encoder, stacked architectures are
the norm, where the output states from the top layer of the stack are taken as the
ﬁnal representation, and the encoder consists of stacked biLSTMs where the hidden
states from top layers from the forward and backward passes are concatenated to
provide the contextualized representations for each time step.
EncoderDecoder
hn hd1he3he2he1hd2hd3hd4embeddinglayerhiddenlayer(s)softmaxx1x2y1hdmx3xn<s>y1y2
y2y3
y3y4
ym-1</s>hen = c = hd0(output is ignored during encoding)……
Figure 13.18 A more formal version of translating a sentence at inference time in the basic RNN-based
encoder-decoder architecture. The ﬁnal hidden state of the encoder RNN, hen, serves as the context for the
decoder in its role as hd
0in the decoder RNN, and is also made available to each decoder hidden state.
The entire purpose of the encoder is to generate a contextualized representation
of the input. This representation is embodied in the ﬁnal hidden state of the encoder,
he
n. This representation, also called cforcontext , is then passed to the decoder.
The simplest version of the decoder network would take this state and use it just
to initialize the ﬁrst hidden state of the decoder; the ﬁrst decoder RNN cell would

13.7 • T HEENCODER -DECODER MODEL WITH RNN S299
usecas its prior hidden state hd
0. The decoder would then autoregressively generate
a sequence of outputs, an element at a time, until an end-of-sequence marker is
generated. Each hidden state is conditioned on the previous hidden state and the
output generated in the previous state.
As Fig. 13.18 shows, we do something more complex: we make the context
vector cavailable to more than just the ﬁrst decoder hidden state, to ensure that the
inﬂuence of the context vector, c, doesn’t wane as the output sequence is generated.
We do this by adding cas a parameter to the computation of the current hidden state.
using the following equation:
hd
t=g(ˆyt−1,hd
t−1,c) (13.32)
Now we’re ready to see the full equations for this version of the decoder in the basic
encoder-decoder model, with context available at each decoding timestep. Recall
thatgis a stand-in for some ﬂavor of RNN and ˆ yt−1is the embedding for the output
sampled from the softmax at the previous step:
c=he
n
hd
0=c
hd
t=g(ˆyt−1,hd
t−1,c)
ˆ yt=softmax (hd
t) (13.33)
Thus ˆ ytis a vector of probabilities over the vocabulary, representing the probability
of each word occurring at time t. To generate text, we sample from this distribution
ˆ yt. For example, the greedy choice is simply to choose the most probable word to
generate at each timestep. We discussed other sampling methods in Section 7.4.
13.7.1 Training the Encoder-Decoder Model
Encoder-decoder architectures are trained end-to-end. Each training example is a
tuple of paired strings, a source and a target. Concatenated with a separator token,
these source-target pairs can now serve as training data.
For MT, the training data typically consists of sets of sentences and their transla-
tions. These can be drawn from standard datasets of aligned sentence pairs, as we’ll
discuss in Section 12.2.2. Once we have a training set, the training itself proceeds
as with any RNN-based language model. The network is given the source text and
then starting with the separator token is trained autoregressively to predict the next
word, as shown in Fig. 13.19.
Note the differences between training (Fig. 13.19) and inference (Fig. 13.17)
with respect to the outputs at each time step. The decoder during inference uses its
own estimated output ˆ ytas the input for the next time step xt+1. Thus the decoder will
tend to deviate more and more from the gold target sentence as it keeps generating
more tokens. In training, therefore, it is more common to use teacher forcing in the teacher forcing
decoder. Teacher forcing means that we force the system to use the gold target token
from training as the next input xt+1, rather than allowing it to rely on the (possibly
erroneous) decoder output ˆ yt. This speeds up training.

300 CHAPTER 13 • RNN S AND LSTM S
EncoderDecoder
embeddinglayerhiddenlayer(s)softmaxthegreenllegó
witcharrived<s>llególa
labruja
brujaverde
verde</s>goldanswersL1 =-log P(y1)
x1x2x3x4L2 =-log P(y2)L3 =-log P(y3)L4 =-log P(y4)L5 =-log P(y5)per-wordlossy1y2y3y4y5Total loss is the average cross-entropy loss per target word:
Figure 13.19 Training the basic RNN encoder-decoder approach to machine translation. Note that in the
decoder we usually don’t propagate the model’s softmax outputs ˆ yt, but use teacher forcing to force each input
to the correct gold value for training. We compute the softmax output distribution over ˆ yin the decoder in order
to compute the loss at each token, which can then be averaged to compute a loss for the sentence. This loss is
then propagated through the decoder parameters and the encoder parameters.
13.8 Attention
The simplicity of the encoder-decoder model is its clean separation of the encoder—
which builds a representation of the source text—from the decoder, which uses this
context to generate a target text. In the model as we’ve described it so far, this
context vector is hn, the hidden state of the last ( nth) time step of the source text.
This ﬁnal hidden state is thus acting as a bottleneck : it must represent absolutely
everything about the meaning of the source text, since the only thing the decoder
knows about the source text is what’s in this context vector (Fig. 13.20). Information
at the beginning of the sentence, especially for long sentences, may not be equally
well represented in the context vector.
EncoderDecoderbottleneckbottleneck
Figure 13.20 Requiring the context cto be only the encoder’s ﬁnal hidden state forces all
the information from the entire source sentence to pass through this representational bottle-
neck.
The attention mechanism is a solution to the bottleneck problem, a way ofattention
mechanism
allowing the decoder to get information from allthe hidden states of the encoder,
not just the last hidden state.
In the attention mechanism, as in the vanilla encoder-decoder model, the context
vector cis a single vector that is a function of the hidden states of the encoder. But
instead of being taken from the last hidden state, it’s a weighted average of allthe

13.8 • A TTENTION 301
hidden states of the encoder. And this weighted average is also informed by part of
the decoder state as well, the state of the decoder right before the current token i.
That is, ci=f(he
1...he
n,hd
i−1). The weights focus on (‘attend to’) a particular part of
the source text that is relevant for the token ithat the decoder is currently producing.
Attention thus replaces the static context vector with one that is dynamically derived
from the encoder hidden states, but also informed by and hence different for each
token in decoding.
This context vector, ci, is generated anew with each decoding step iand takes
all of the encoder hidden states into account in its derivation. We then make this
context available during decoding by conditioning the computation of the current
decoder hidden state on it (along with the prior hidden state and the previous output
generated by the decoder), as we see in this equation (and Fig. 13.21):
hd
i=g(ˆyi−1,hd
i−1,ci) (13.34)
hd1hd2hdiy1y2yic1c2ci……
Figure 13.21 The attention mechanism allows each hidden state of the decoder to see a
different, dynamic, context, which is a function of all the encoder hidden states.
The ﬁrst step in computing ciis to compute how much to focus on each encoder
state, how relevant each encoder state is to the decoder state captured in hd
i−1. We
capture relevance by computing— at each state iduring decoding—a score(hd
i−1,he
j)
for each encoder state j.
The simplest such score, called dot-product attention , implements relevance asdot-product
attention
similarity: measuring how similar the decoder hidden state is to an encoder hidden
state, by computing the dot product between them:
score(hd
i−1,he
j) = hd
i−1·he
j (13.35)
The score that results from this dot product is a scalar that reﬂects the degree of
similarity between the two vectors. The vector of these scores across all the encoder
hidden states gives us the relevance of each encoder state to the current step of the
decoder.
To make use of these scores, we’ll normalize them with a softmax to create a
vector of weights, αi j, that tells us the proportional relevance of each encoder hidden
state jto the prior hidden decoder state, hd
i−1.
αi j=softmax (score(hd
i−1,he
j))
=exp(score(hd
i−1,he
j)
∑
kexp(score(hd
i−1,he
k))(13.36)
Finally, given the distribution in α, we can compute a ﬁxed-length context vector for
the current decoder state by taking a weighted average over all the encoder hidden
states.
ci=∑
jαi jhe
j (13.37)

302 CHAPTER 13 • RNN S AND LSTM S
With this, we ﬁnally have a ﬁxed-length context vector that takes into account
information from the entire encoder state that is dynamically updated to reﬂect the
needs of the decoder at each step of decoding. Fig. 13.22 illustrates an encoder-
decoder network with attention, focusing on the computation of one context vector
ci.
EncoderDecoder
hdi-1he3he2he1hdihiddenlayer(s)x1x2yi-1x3xnyi-2yi-1yihen ci.2.1.3.4attentionweightsci-1ci
<latexit sha1_base64="TNdNmv/RIlrhPa6LgQyjjQLqyBA=">AAACAnicdVDLSsNAFJ3UV62vqCtxM1gEVyHpI9Vd0Y3LCvYBTQyT6bSddvJgZiKUUNz4K25cKOLWr3Dn3zhpK6jogQuHc+7l3nv8mFEhTfNDyy0tr6yu5dcLG5tb2zv67l5LRAnHpIkjFvGOjwRhNCRNSSUjnZgTFPiMtP3xRea3bwkXNAqv5SQmboAGIe1TjKSSPP3AEUngjVIHsXiIvJSOpnB4Q7zR1NOLpmGaVbtqQdOwLbtk24qY5Yp9VoOWsjIUwQINT393ehFOAhJKzJAQXcuMpZsiLilmZFpwEkFihMdoQLqKhiggwk1nL0zhsVJ6sB9xVaGEM/X7RIoCISaBrzoDJIfit5eJf3ndRPZP3ZSGcSJJiOeL+gmDMoJZHrBHOcGSTRRBmFN1K8RDxBGWKrWCCuHrU/g/aZUMyzbKV5Vi/XwRRx4cgiNwAixQA3VwCRqgCTC4Aw/gCTxr99qj9qK9zltz2mJmH/yA9vYJSymYCA==</latexit>Xj↵ijhej↵ij<latexit sha1_base64="y8s4mGdpwrGrBnuSR+p1gJJXYdo=">AAAB/nicdVDJSgNBEO2JW4zbqHjy0hgEL4YeJyQBL0EvHiOYBbIMPT09mTY9C909QhgC/ooXD4p49Tu8+Td2FkFFHxQ83quiqp6bcCYVQh9Gbml5ZXUtv17Y2Nza3jF391oyTgWhTRLzWHRcLClnEW0qpjjtJILi0OW07Y4up377jgrJ4uhGjRPaD/EwYj4jWGnJMQ+Cgedk7NSa9IgXq955MKDOrWMWUQnNAFGpYtfsakUTZNtWGUFrYRXBAg3HfO95MUlDGinCsZRdCyWqn2GhGOF0UuilkiaYjPCQdjWNcEhlP5udP4HHWvGgHwtdkYIz9ftEhkMpx6GrO0OsAvnbm4p/ed1U+bV+xqIkVTQi80V+yqGK4TQL6DFBieJjTTARTN8KSYAFJkonVtAhfH0K/yets5JVKdnX5WL9YhFHHhyCI3ACLFAFdXAFGqAJCMjAA3gCz8a98Wi8GK/z1pyxmNkHP2C8fQICDpWK</latexit>hdi 1·hej………
Figure 13.22 A sketch of the encoder-decoder network with attention, focusing on the computation of ci.
The context value ciis one of the inputs to the computation of hd
i. It is computed by taking the weighted sum
of all the encoder hidden states, each weighted by their dot product with the prior decoder hidden state hd
i−1.
It’s also possible to create more sophisticated scoring functions for attention
models. Instead of simple dot product attention, we can get a more powerful function
that computes the relevance of each encoder hidden state to the decoder hidden state
by parameterizing the score with its own set of weights, Ws.
score(hd
i−1,he
j) = hd
i−1Wshe
j (13.38)
The weights Ws, which are then trained during normal end-to-end training, give the
network the ability to learn which aspects of similarity between the decoder and
encoder states are important to the current application. This bilinear model also
allows the encoder and decoder to use different dimensional vectors, whereas the
simple dot-product attention requires that the encoder and decoder hidden states
have the same dimensionality.
We’ll return to the concept of attention when we deﬁne the transformer archi-
tecture in Chapter 8, which is based on a slight modiﬁcation of attention called
self-attention .
13.9 Summary
This chapter has introduced the concepts of recurrent neural networks and how they
can be applied to language problems. Here’s a summary of the main points that we
covered:
• In simple Recurrent Neural Networks sequences are processed one element at
a time, with the output of each neural unit at time tbased both on the current
input at tand the hidden layer from time t−1.

HISTORICAL NOTES 303
• RNNs can be trained with a straightforward extension of the backpropagation
algorithm, known as backpropagation through time (BPTT).
• Simple recurrent networks fail on long inputs because of problems like van-
ishing gradients ; instead modern systems use more complex gated architec-
tures such as LSTMs that explicitly decide what to remember and forget in
their hidden and context layers.
• Common language-based applications for RNNs include:
–Probabilistic language modeling: assigning a probability to a sequence,
or to the next element of a sequence given the preceding words.
–Auto-regressive generation using a trained language model.
–Sequence labeling like part-of-speech tagging, where each element of a
sequence is assigned a label.
–Sequence classiﬁcation, where an entire text is assigned to a category, as
in spam detection, sentiment analysis or topic classiﬁcation.
–Encoder-decoder architectures, where an input is mapped to an output
of different length and alignment.
Historical Notes
Inﬂuential investigations of RNNs were conducted in the context of the Parallel Dis-
tributed Processing (PDP) group at UC San Diego in the 1980’s. Much of this work
was directed at human cognitive modeling rather than practical NLP applications
(Rumelhart and McClelland 1986c, McClelland and Rumelhart 1986). Models using
recurrence at the hidden layer in a feedforward network (Elman networks) were in-
troduced by Elman (1990). Similar architectures were investigated by Jordan (1986)
with a recurrence from the output layer, and Mathis and Mozer (1995) with the
addition of a recurrent context layer prior to the hidden layer. The possibility of
unrolling a recurrent network into an equivalent feedforward network is discussed
in (Rumelhart and McClelland, 1986c).
In parallel with work in cognitive modeling, RNNs were investigated extensively
in the continuous domain in the signal processing and speech communities (Giles
et al. 1994, Robinson et al. 1996). Schuster and Paliwal (1997) introduced bidirec-
tional RNNs and described results on the TIMIT phoneme transcription task.
While theoretically interesting, the difﬁculty with training RNNs and manag-
ing context over long sequences impeded progress on practical applications. This
situation changed with the introduction of LSTMs in Hochreiter and Schmidhuber
(1997) and Gers et al. (2000). Impressive performance gains were demonstrated
on tasks at the boundary of signal processing and language processing including
phoneme recognition (Graves and Schmidhuber, 2005), handwriting recognition
(Graves et al., 2007) and most signiﬁcantly speech recognition (Graves et al., 2013).
Interest in applying neural networks to practical NLP problems surged with the
work of Collobert and Weston (2008) and Collobert et al. (2011). These efforts made
use of learned word embeddings, convolutional networks, and end-to-end training.
They demonstrated near state-of-the-art performance on a number of standard shared
tasks including part-of-speech tagging, chunking, named entity recognition and se-
mantic role labeling without the use of hand-engineered features.
Approaches that married LSTMs with pretrained collections of word-embeddings
based on word2vec (Mikolov et al., 2013a) and GloVe (Pennington et al., 2014)

304 CHAPTER 13 • RNN S AND LSTM S
quickly came to dominate many common tasks: part-of-speech tagging (Ling et al.,
2015), syntactic chunking (Søgaard and Goldberg, 2016), named entity recognition
(Chiu and Nichols, 2016; Ma and Hovy, 2016), opinion mining (Irsoy and Cardie,
2014), semantic role labeling (Zhou and Xu, 2015a) and AMR parsing (Foland and
Martin, 2016). As with the earlier surge of progress involving statistical machine
learning, these advances were made possible by the availability of training data pro-
vided by CONLL, SemEval, and other shared tasks, as well as shared resources such
as Ontonotes (Pradhan et al., 2007b), and PropBank (Palmer et al., 2005).
The modern neural encoder-decoder approach was pioneered by Kalchbrenner
and Blunsom (2013), who used a CNN encoder and an RNN decoder. Cho et al.
(2014) (who coined the name “encoder-decoder”) and Sutskever et al. (2014) then
showed how to use extended RNNs for both encoder and decoder. The idea that a
generative decoder should take as input a soft weighting of the inputs, the central
idea of attention, was ﬁrst developed by Graves (2013) in the context of handwriting
recognition. Bahdanau et al. (2015) extended the idea, named it “attention” and
applied it to MT.

